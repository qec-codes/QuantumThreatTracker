[
    {
        "protocol": "RSA-512",
        "threats": [
            {
                "timestamp": 2493072000,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 4096000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 4086288,
                        "runtime": 1621897754400,
                        "rqops": 379047620,
                        "breakdown": {
                            "algorithmicLogicalQubits": 3184,
                            "algorithmicLogicalDepth": 193083066,
                            "logicalDepth": 193083066,
                            "numTstates": 257444088,
                            "clockFrequency": 119047.61904761905,
                            "numTfactories": 71,
                            "numTfactoryRuns": 3625974,
                            "physicalQubitsForTfactories": 1278000,
                            "physicalQubitsForAlgorithm": 2808288,
                            "requiredLogicalQubitErrorRate": 7.319733481519155e-13,
                            "requiredLogicalTstateErrorRate": 1.7479523553867743e-09,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "27 mins",
                        "rqops": "379.05M",
                        "physicalQubits": "4.09M",
                        "algorithmicLogicalQubits": "3.18k",
                        "algorithmicLogicalDepth": "193.08M",
                        "logicalDepth": "193.08M",
                        "numTstates": "257.44M",
                        "numTfactories": "71",
                        "numTfactoryRuns": "3.63M",
                        "physicalQubitsForAlgorithm": "2.81M",
                        "physicalQubitsForTfactories": "1.28M",
                        "physicalQubitsForTfactoriesPercentage": "31.28 %",
                        "requiredLogicalQubitErrorRate": "7.32e-13",
                        "requiredLogicalTstateErrorRate": "1.75e-9",
                        "physicalQubitsPerLogicalQubit": "882",
                        "logicalCycleTime": "8 microsecs",
                        "clockFrequency": "119.05k",
                        "logicalErrorRate": "3.00e-13",
                        "tfactoryPhysicalQubits": "18.00k",
                        "tfactoryRuntime": "101 microsecs",
                        "numInputTstates": "270",
                        "numUnitsPerRound": "18, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "5, 17",
                        "physicalQubitsPerRound": "18.00k, 17.92k",
                        "tfactoryRuntimePerRound": "26 microsecs, 75 microsecs",
                        "tstateLogicalErrorRate": "5.51e-10",
                        "logicalCountsNumQubits": "1.54k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "64.36M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "4096000"
                    },
                    "logicalQubit": {
                        "codeDistance": 21,
                        "physicalQubits": 882,
                        "logicalCycleTime": 8400,
                        "logicalErrorRate": 3.000000000000003e-13
                    },
                    "tfactory": {
                        "physicalQubits": 18000,
                        "runtime": 100800,
                        "numTstates": 1,
                        "numInputTstates": 270,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            18,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            5,
                            17
                        ],
                        "physicalQubitsPerRound": [
                            18000,
                            17918
                        ],
                        "runtimePerRound": [
                            26000,
                            74800
                        ],
                        "logicalErrorRate": 5.513926534736261e-10
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 1536,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 64361022,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (8,400 nanosecs) multiplied by the 193,083,066 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 100,800 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (3,184) (with a logical error rate of 7.32e-13) multiplied by the clock frequency (119,047.62), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 2,808,288 physical qubits to implement the algorithm logic, and 1,278,000 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 1,536$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 3,184$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 64,361,022 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 193,083,066.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 8 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 64,361,022 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 257,444,088 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 71 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{257,444,088 \\cdot 100,800\\;\\text{ns}}{1 \\cdot 1,621,897,754,400\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 257,444,088 T states, the 71 copies of the T factory are repeatedly invoked 3,625,974 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 2,808,288 are the product of the 3,184 logical qubits after layout and the 882 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 18,000 physical qubits and we run 71 in parallel, therefore we need $1,278,000 = 18,000 \\cdot 71$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 3,184 logical qubits and the total cycle count 193,083,066."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 257,444,088."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000007319733481519155)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{21 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 8,400 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 882."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 270 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 5.51e-10."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.75e-9."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 3,184 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2556187200,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 8192000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 8190288,
                        "runtime": 1621897754400,
                        "rqops": 379047620,
                        "breakdown": {
                            "algorithmicLogicalQubits": 3184,
                            "algorithmicLogicalDepth": 193083066,
                            "logicalDepth": 193083066,
                            "numTstates": 257444088,
                            "clockFrequency": 119047.61904761905,
                            "numTfactories": 299,
                            "numTfactoryRuns": 861018,
                            "physicalQubitsForTfactories": 5382000,
                            "physicalQubitsForAlgorithm": 2808288,
                            "requiredLogicalQubitErrorRate": 7.319733481519155e-13,
                            "requiredLogicalTstateErrorRate": 1.7479523553867743e-09,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "27 mins",
                        "rqops": "379.05M",
                        "physicalQubits": "8.19M",
                        "algorithmicLogicalQubits": "3.18k",
                        "algorithmicLogicalDepth": "193.08M",
                        "logicalDepth": "193.08M",
                        "numTstates": "257.44M",
                        "numTfactories": "299",
                        "numTfactoryRuns": "861.02k",
                        "physicalQubitsForAlgorithm": "2.81M",
                        "physicalQubitsForTfactories": "5.38M",
                        "physicalQubitsForTfactoriesPercentage": "65.71 %",
                        "requiredLogicalQubitErrorRate": "7.32e-13",
                        "requiredLogicalTstateErrorRate": "1.75e-9",
                        "physicalQubitsPerLogicalQubit": "882",
                        "logicalCycleTime": "8 microsecs",
                        "clockFrequency": "119.05k",
                        "logicalErrorRate": "3.00e-13",
                        "tfactoryPhysicalQubits": "18.00k",
                        "tfactoryRuntime": "101 microsecs",
                        "numInputTstates": "270",
                        "numUnitsPerRound": "18, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "5, 17",
                        "physicalQubitsPerRound": "18.00k, 17.92k",
                        "tfactoryRuntimePerRound": "26 microsecs, 75 microsecs",
                        "tstateLogicalErrorRate": "5.51e-10",
                        "logicalCountsNumQubits": "1.54k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "64.36M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "8192000"
                    },
                    "logicalQubit": {
                        "codeDistance": 21,
                        "physicalQubits": 882,
                        "logicalCycleTime": 8400,
                        "logicalErrorRate": 3.000000000000003e-13
                    },
                    "tfactory": {
                        "physicalQubits": 18000,
                        "runtime": 100800,
                        "numTstates": 1,
                        "numInputTstates": 270,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            18,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            5,
                            17
                        ],
                        "physicalQubitsPerRound": [
                            18000,
                            17918
                        ],
                        "runtimePerRound": [
                            26000,
                            74800
                        ],
                        "logicalErrorRate": 5.513926534736261e-10
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 1536,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 64361022,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (8,400 nanosecs) multiplied by the 193,083,066 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 100,800 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (3,184) (with a logical error rate of 7.32e-13) multiplied by the clock frequency (119,047.62), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 2,808,288 physical qubits to implement the algorithm logic, and 5,382,000 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 1,536$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 3,184$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 64,361,022 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 193,083,066.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 8 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 64,361,022 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 257,444,088 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 299 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{257,444,088 \\cdot 100,800\\;\\text{ns}}{1 \\cdot 1,621,897,754,400\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 257,444,088 T states, the 299 copies of the T factory are repeatedly invoked 861,018 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 2,808,288 are the product of the 3,184 logical qubits after layout and the 882 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 18,000 physical qubits and we run 299 in parallel, therefore we need $5,382,000 = 18,000 \\cdot 299$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 3,184 logical qubits and the total cycle count 193,083,066."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 257,444,088."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000007319733481519155)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{21 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 8,400 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 882."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 270 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 5.51e-10."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.75e-9."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 3,184 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2556187200,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 819200,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 819128,
                        "runtime": 1274348235600000,
                        "rqops": 482425,
                        "breakdown": {
                            "algorithmicLogicalQubits": 3184,
                            "algorithmicLogicalDepth": 193083066,
                            "logicalDepth": 193083066,
                            "numTstates": 257444088,
                            "clockFrequency": 151.5151515151515,
                            "numTfactories": 15,
                            "numTfactoryRuns": 17162940,
                            "physicalQubitsForTfactories": 48600,
                            "physicalQubitsForAlgorithm": 770528,
                            "requiredLogicalQubitErrorRate": 7.319733481519155e-13,
                            "requiredLogicalTstateErrorRate": 1.7479523553867743e-09,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "15 days",
                        "rqops": "482.43k",
                        "physicalQubits": "819.13k",
                        "algorithmicLogicalQubits": "3.18k",
                        "algorithmicLogicalDepth": "193.08M",
                        "logicalDepth": "193.08M",
                        "numTstates": "257.44M",
                        "numTfactories": "15",
                        "numTfactoryRuns": "17.16M",
                        "physicalQubitsForAlgorithm": "770.53k",
                        "physicalQubitsForTfactories": "48.60k",
                        "physicalQubitsForTfactoriesPercentage": "5.93 %",
                        "requiredLogicalQubitErrorRate": "7.32e-13",
                        "requiredLogicalTstateErrorRate": "1.75e-9",
                        "physicalQubitsPerLogicalQubit": "242",
                        "logicalCycleTime": "7 millisecs",
                        "clockFrequency": "152",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "1.54k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "64.36M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "819200"
                    },
                    "logicalQubit": {
                        "codeDistance": 11,
                        "physicalQubits": 242,
                        "logicalCycleTime": 6600000,
                        "logicalErrorRate": 3e-14
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 1536,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 64361022,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (6,600,000 nanosecs) multiplied by the 193,083,066 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (3,184) (with a logical error rate of 7.32e-13) multiplied by the clock frequency (151.52), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 770,528 physical qubits to implement the algorithm logic, and 48,600 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 1,536$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 3,184$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 64,361,022 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 193,083,066.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 7 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 64,361,022 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 257,444,088 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 15 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{257,444,088 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 1,274,348,235,600,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 257,444,088 T states, the 15 copies of the T factory are repeatedly invoked 17,162,940 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 770,528 are the product of the 3,184 logical qubits after layout and the 242 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 15 in parallel, therefore we need $48,600 = 3,240 \\cdot 15$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 3,184 logical qubits and the total cycle count 193,083,066."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 257,444,088."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000007319733481519155)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{11 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 6,600,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 242."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.75e-9."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 3,184 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2619302400,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 16384000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 16380288,
                        "runtime": 1621897754400,
                        "rqops": 379047620,
                        "breakdown": {
                            "algorithmicLogicalQubits": 3184,
                            "algorithmicLogicalDepth": 193083066,
                            "logicalDepth": 193083066,
                            "numTstates": 257444088,
                            "clockFrequency": 119047.61904761905,
                            "numTfactories": 754,
                            "numTfactoryRuns": 341438,
                            "physicalQubitsForTfactories": 13572000,
                            "physicalQubitsForAlgorithm": 2808288,
                            "requiredLogicalQubitErrorRate": 7.319733481519155e-13,
                            "requiredLogicalTstateErrorRate": 1.7479523553867743e-09,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "27 mins",
                        "rqops": "379.05M",
                        "physicalQubits": "16.38M",
                        "algorithmicLogicalQubits": "3.18k",
                        "algorithmicLogicalDepth": "193.08M",
                        "logicalDepth": "193.08M",
                        "numTstates": "257.44M",
                        "numTfactories": "754",
                        "numTfactoryRuns": "341.44k",
                        "physicalQubitsForAlgorithm": "2.81M",
                        "physicalQubitsForTfactories": "13.57M",
                        "physicalQubitsForTfactoriesPercentage": "82.86 %",
                        "requiredLogicalQubitErrorRate": "7.32e-13",
                        "requiredLogicalTstateErrorRate": "1.75e-9",
                        "physicalQubitsPerLogicalQubit": "882",
                        "logicalCycleTime": "8 microsecs",
                        "clockFrequency": "119.05k",
                        "logicalErrorRate": "3.00e-13",
                        "tfactoryPhysicalQubits": "18.00k",
                        "tfactoryRuntime": "101 microsecs",
                        "numInputTstates": "270",
                        "numUnitsPerRound": "18, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "5, 17",
                        "physicalQubitsPerRound": "18.00k, 17.92k",
                        "tfactoryRuntimePerRound": "26 microsecs, 75 microsecs",
                        "tstateLogicalErrorRate": "5.51e-10",
                        "logicalCountsNumQubits": "1.54k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "64.36M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "16384000"
                    },
                    "logicalQubit": {
                        "codeDistance": 21,
                        "physicalQubits": 882,
                        "logicalCycleTime": 8400,
                        "logicalErrorRate": 3.000000000000003e-13
                    },
                    "tfactory": {
                        "physicalQubits": 18000,
                        "runtime": 100800,
                        "numTstates": 1,
                        "numInputTstates": 270,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            18,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            5,
                            17
                        ],
                        "physicalQubitsPerRound": [
                            18000,
                            17918
                        ],
                        "runtimePerRound": [
                            26000,
                            74800
                        ],
                        "logicalErrorRate": 5.513926534736261e-10
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 1536,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 64361022,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (8,400 nanosecs) multiplied by the 193,083,066 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 100,800 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (3,184) (with a logical error rate of 7.32e-13) multiplied by the clock frequency (119,047.62), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 2,808,288 physical qubits to implement the algorithm logic, and 13,572,000 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 1,536$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 3,184$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 64,361,022 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 193,083,066.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 8 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 64,361,022 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 257,444,088 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 754 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{257,444,088 \\cdot 100,800\\;\\text{ns}}{1 \\cdot 1,621,897,754,400\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 257,444,088 T states, the 754 copies of the T factory are repeatedly invoked 341,438 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 2,808,288 are the product of the 3,184 logical qubits after layout and the 882 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 18,000 physical qubits and we run 754 in parallel, therefore we need $13,572,000 = 18,000 \\cdot 754$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 3,184 logical qubits and the total cycle count 193,083,066."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 257,444,088."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000007319733481519155)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{21 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 8,400 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 882."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 270 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 5.51e-10."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.75e-9."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 3,184 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2619302400,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 1638400,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 1635608,
                        "runtime": 1274348235600000,
                        "rqops": 482425,
                        "breakdown": {
                            "algorithmicLogicalQubits": 3184,
                            "algorithmicLogicalDepth": 193083066,
                            "logicalDepth": 193083066,
                            "numTstates": 257444088,
                            "clockFrequency": 151.5151515151515,
                            "numTfactories": 267,
                            "numTfactoryRuns": 964211,
                            "physicalQubitsForTfactories": 865080,
                            "physicalQubitsForAlgorithm": 770528,
                            "requiredLogicalQubitErrorRate": 7.319733481519155e-13,
                            "requiredLogicalTstateErrorRate": 1.7479523553867743e-09,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "15 days",
                        "rqops": "482.43k",
                        "physicalQubits": "1.64M",
                        "algorithmicLogicalQubits": "3.18k",
                        "algorithmicLogicalDepth": "193.08M",
                        "logicalDepth": "193.08M",
                        "numTstates": "257.44M",
                        "numTfactories": "267",
                        "numTfactoryRuns": "964.21k",
                        "physicalQubitsForAlgorithm": "770.53k",
                        "physicalQubitsForTfactories": "865.08k",
                        "physicalQubitsForTfactoriesPercentage": "52.89 %",
                        "requiredLogicalQubitErrorRate": "7.32e-13",
                        "requiredLogicalTstateErrorRate": "1.75e-9",
                        "physicalQubitsPerLogicalQubit": "242",
                        "logicalCycleTime": "7 millisecs",
                        "clockFrequency": "152",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "1.54k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "64.36M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "1638400"
                    },
                    "logicalQubit": {
                        "codeDistance": 11,
                        "physicalQubits": 242,
                        "logicalCycleTime": 6600000,
                        "logicalErrorRate": 3e-14
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 1536,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 64361022,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (6,600,000 nanosecs) multiplied by the 193,083,066 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (3,184) (with a logical error rate of 7.32e-13) multiplied by the clock frequency (151.52), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 770,528 physical qubits to implement the algorithm logic, and 865,080 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 1,536$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 3,184$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 64,361,022 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 193,083,066.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 7 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 64,361,022 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 257,444,088 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 267 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{257,444,088 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 1,274,348,235,600,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 257,444,088 T states, the 267 copies of the T factory are repeatedly invoked 964,211 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 770,528 are the product of the 3,184 logical qubits after layout and the 242 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 267 in parallel, therefore we need $865,080 = 3,240 \\cdot 267$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 3,184 logical qubits and the total cycle count 193,083,066."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 257,444,088."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000007319733481519155)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{11 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 6,600,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 242."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.75e-9."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 3,184 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2682417600,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 32768000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 32760288,
                        "runtime": 1621897754400,
                        "rqops": 379047620,
                        "breakdown": {
                            "algorithmicLogicalQubits": 3184,
                            "algorithmicLogicalDepth": 193083066,
                            "logicalDepth": 193083066,
                            "numTstates": 257444088,
                            "clockFrequency": 119047.61904761905,
                            "numTfactories": 1664,
                            "numTfactoryRuns": 154714,
                            "physicalQubitsForTfactories": 29952000,
                            "physicalQubitsForAlgorithm": 2808288,
                            "requiredLogicalQubitErrorRate": 7.319733481519155e-13,
                            "requiredLogicalTstateErrorRate": 1.7479523553867743e-09,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "27 mins",
                        "rqops": "379.05M",
                        "physicalQubits": "32.76M",
                        "algorithmicLogicalQubits": "3.18k",
                        "algorithmicLogicalDepth": "193.08M",
                        "logicalDepth": "193.08M",
                        "numTstates": "257.44M",
                        "numTfactories": "1.66k",
                        "numTfactoryRuns": "154.71k",
                        "physicalQubitsForAlgorithm": "2.81M",
                        "physicalQubitsForTfactories": "29.95M",
                        "physicalQubitsForTfactoriesPercentage": "91.43 %",
                        "requiredLogicalQubitErrorRate": "7.32e-13",
                        "requiredLogicalTstateErrorRate": "1.75e-9",
                        "physicalQubitsPerLogicalQubit": "882",
                        "logicalCycleTime": "8 microsecs",
                        "clockFrequency": "119.05k",
                        "logicalErrorRate": "3.00e-13",
                        "tfactoryPhysicalQubits": "18.00k",
                        "tfactoryRuntime": "101 microsecs",
                        "numInputTstates": "270",
                        "numUnitsPerRound": "18, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "5, 17",
                        "physicalQubitsPerRound": "18.00k, 17.92k",
                        "tfactoryRuntimePerRound": "26 microsecs, 75 microsecs",
                        "tstateLogicalErrorRate": "5.51e-10",
                        "logicalCountsNumQubits": "1.54k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "64.36M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "32768000"
                    },
                    "logicalQubit": {
                        "codeDistance": 21,
                        "physicalQubits": 882,
                        "logicalCycleTime": 8400,
                        "logicalErrorRate": 3.000000000000003e-13
                    },
                    "tfactory": {
                        "physicalQubits": 18000,
                        "runtime": 100800,
                        "numTstates": 1,
                        "numInputTstates": 270,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            18,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            5,
                            17
                        ],
                        "physicalQubitsPerRound": [
                            18000,
                            17918
                        ],
                        "runtimePerRound": [
                            26000,
                            74800
                        ],
                        "logicalErrorRate": 5.513926534736261e-10
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 1536,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 64361022,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (8,400 nanosecs) multiplied by the 193,083,066 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 100,800 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (3,184) (with a logical error rate of 7.32e-13) multiplied by the clock frequency (119,047.62), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 2,808,288 physical qubits to implement the algorithm logic, and 29,952,000 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 1,536$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 3,184$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 64,361,022 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 193,083,066.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 8 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 64,361,022 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 257,444,088 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 1,664 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{257,444,088 \\cdot 100,800\\;\\text{ns}}{1 \\cdot 1,621,897,754,400\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 257,444,088 T states, the 1,664 copies of the T factory are repeatedly invoked 154,714 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 2,808,288 are the product of the 3,184 logical qubits after layout and the 882 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 18,000 physical qubits and we run 1,664 in parallel, therefore we need $29,952,000 = 18,000 \\cdot 1,664$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 3,184 logical qubits and the total cycle count 193,083,066."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 257,444,088."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000007319733481519155)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{21 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 8,400 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 882."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 270 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 5.51e-10."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.75e-9."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 3,184 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2682417600,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 3276800,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 3275048,
                        "runtime": 1274348235600000,
                        "rqops": 482425,
                        "breakdown": {
                            "algorithmicLogicalQubits": 3184,
                            "algorithmicLogicalDepth": 193083066,
                            "logicalDepth": 193083066,
                            "numTstates": 257444088,
                            "clockFrequency": 151.5151515151515,
                            "numTfactories": 773,
                            "numTfactoryRuns": 333046,
                            "physicalQubitsForTfactories": 2504520,
                            "physicalQubitsForAlgorithm": 770528,
                            "requiredLogicalQubitErrorRate": 7.319733481519155e-13,
                            "requiredLogicalTstateErrorRate": 1.7479523553867743e-09,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "15 days",
                        "rqops": "482.43k",
                        "physicalQubits": "3.28M",
                        "algorithmicLogicalQubits": "3.18k",
                        "algorithmicLogicalDepth": "193.08M",
                        "logicalDepth": "193.08M",
                        "numTstates": "257.44M",
                        "numTfactories": "773",
                        "numTfactoryRuns": "333.05k",
                        "physicalQubitsForAlgorithm": "770.53k",
                        "physicalQubitsForTfactories": "2.50M",
                        "physicalQubitsForTfactoriesPercentage": "76.47 %",
                        "requiredLogicalQubitErrorRate": "7.32e-13",
                        "requiredLogicalTstateErrorRate": "1.75e-9",
                        "physicalQubitsPerLogicalQubit": "242",
                        "logicalCycleTime": "7 millisecs",
                        "clockFrequency": "152",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "1.54k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "64.36M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "3276800"
                    },
                    "logicalQubit": {
                        "codeDistance": 11,
                        "physicalQubits": 242,
                        "logicalCycleTime": 6600000,
                        "logicalErrorRate": 3e-14
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 1536,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 64361022,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (6,600,000 nanosecs) multiplied by the 193,083,066 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (3,184) (with a logical error rate of 7.32e-13) multiplied by the clock frequency (151.52), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 770,528 physical qubits to implement the algorithm logic, and 2,504,520 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 1,536$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 3,184$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 64,361,022 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 193,083,066.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 7 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 64,361,022 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 257,444,088 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 773 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{257,444,088 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 1,274,348,235,600,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 257,444,088 T states, the 773 copies of the T factory are repeatedly invoked 333,046 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 770,528 are the product of the 3,184 logical qubits after layout and the 242 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 773 in parallel, therefore we need $2,504,520 = 3,240 \\cdot 773$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 3,184 logical qubits and the total cycle count 193,083,066."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 257,444,088."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000007319733481519155)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{11 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 6,600,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 242."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.75e-9."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 3,184 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2745532800,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 65536000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 65520288,
                        "runtime": 1621897754400,
                        "rqops": 379047620,
                        "breakdown": {
                            "algorithmicLogicalQubits": 3184,
                            "algorithmicLogicalDepth": 193083066,
                            "logicalDepth": 193083066,
                            "numTstates": 257444088,
                            "clockFrequency": 119047.61904761905,
                            "numTfactories": 3484,
                            "numTfactoryRuns": 73894,
                            "physicalQubitsForTfactories": 62712000,
                            "physicalQubitsForAlgorithm": 2808288,
                            "requiredLogicalQubitErrorRate": 7.319733481519155e-13,
                            "requiredLogicalTstateErrorRate": 1.7479523553867743e-09,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "27 mins",
                        "rqops": "379.05M",
                        "physicalQubits": "65.52M",
                        "algorithmicLogicalQubits": "3.18k",
                        "algorithmicLogicalDepth": "193.08M",
                        "logicalDepth": "193.08M",
                        "numTstates": "257.44M",
                        "numTfactories": "3.48k",
                        "numTfactoryRuns": "73.89k",
                        "physicalQubitsForAlgorithm": "2.81M",
                        "physicalQubitsForTfactories": "62.71M",
                        "physicalQubitsForTfactoriesPercentage": "95.71 %",
                        "requiredLogicalQubitErrorRate": "7.32e-13",
                        "requiredLogicalTstateErrorRate": "1.75e-9",
                        "physicalQubitsPerLogicalQubit": "882",
                        "logicalCycleTime": "8 microsecs",
                        "clockFrequency": "119.05k",
                        "logicalErrorRate": "3.00e-13",
                        "tfactoryPhysicalQubits": "18.00k",
                        "tfactoryRuntime": "101 microsecs",
                        "numInputTstates": "270",
                        "numUnitsPerRound": "18, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "5, 17",
                        "physicalQubitsPerRound": "18.00k, 17.92k",
                        "tfactoryRuntimePerRound": "26 microsecs, 75 microsecs",
                        "tstateLogicalErrorRate": "5.51e-10",
                        "logicalCountsNumQubits": "1.54k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "64.36M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "65536000"
                    },
                    "logicalQubit": {
                        "codeDistance": 21,
                        "physicalQubits": 882,
                        "logicalCycleTime": 8400,
                        "logicalErrorRate": 3.000000000000003e-13
                    },
                    "tfactory": {
                        "physicalQubits": 18000,
                        "runtime": 100800,
                        "numTstates": 1,
                        "numInputTstates": 270,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            18,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            5,
                            17
                        ],
                        "physicalQubitsPerRound": [
                            18000,
                            17918
                        ],
                        "runtimePerRound": [
                            26000,
                            74800
                        ],
                        "logicalErrorRate": 5.513926534736261e-10
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 1536,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 64361022,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (8,400 nanosecs) multiplied by the 193,083,066 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 100,800 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (3,184) (with a logical error rate of 7.32e-13) multiplied by the clock frequency (119,047.62), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 2,808,288 physical qubits to implement the algorithm logic, and 62,712,000 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 1,536$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 3,184$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 64,361,022 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 193,083,066.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 8 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 64,361,022 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 257,444,088 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 3,484 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{257,444,088 \\cdot 100,800\\;\\text{ns}}{1 \\cdot 1,621,897,754,400\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 257,444,088 T states, the 3,484 copies of the T factory are repeatedly invoked 73,894 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 2,808,288 are the product of the 3,184 logical qubits after layout and the 882 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 18,000 physical qubits and we run 3,484 in parallel, therefore we need $62,712,000 = 18,000 \\cdot 3,484$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 3,184 logical qubits and the total cycle count 193,083,066."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 257,444,088."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000007319733481519155)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{21 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 8,400 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 882."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 270 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 5.51e-10."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.75e-9."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 3,184 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2745532800,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 6553600,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 6550688,
                        "runtime": 1274348235600000,
                        "rqops": 482425,
                        "breakdown": {
                            "algorithmicLogicalQubits": 3184,
                            "algorithmicLogicalDepth": 193083066,
                            "logicalDepth": 193083066,
                            "numTstates": 257444088,
                            "clockFrequency": 151.5151515151515,
                            "numTfactories": 1784,
                            "numTfactoryRuns": 144308,
                            "physicalQubitsForTfactories": 5780160,
                            "physicalQubitsForAlgorithm": 770528,
                            "requiredLogicalQubitErrorRate": 7.319733481519155e-13,
                            "requiredLogicalTstateErrorRate": 1.7479523553867743e-09,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "15 days",
                        "rqops": "482.43k",
                        "physicalQubits": "6.55M",
                        "algorithmicLogicalQubits": "3.18k",
                        "algorithmicLogicalDepth": "193.08M",
                        "logicalDepth": "193.08M",
                        "numTstates": "257.44M",
                        "numTfactories": "1.78k",
                        "numTfactoryRuns": "144.31k",
                        "physicalQubitsForAlgorithm": "770.53k",
                        "physicalQubitsForTfactories": "5.78M",
                        "physicalQubitsForTfactoriesPercentage": "88.24 %",
                        "requiredLogicalQubitErrorRate": "7.32e-13",
                        "requiredLogicalTstateErrorRate": "1.75e-9",
                        "physicalQubitsPerLogicalQubit": "242",
                        "logicalCycleTime": "7 millisecs",
                        "clockFrequency": "152",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "1.54k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "64.36M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "6553600"
                    },
                    "logicalQubit": {
                        "codeDistance": 11,
                        "physicalQubits": 242,
                        "logicalCycleTime": 6600000,
                        "logicalErrorRate": 3e-14
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 1536,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 64361022,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (6,600,000 nanosecs) multiplied by the 193,083,066 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (3,184) (with a logical error rate of 7.32e-13) multiplied by the clock frequency (151.52), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 770,528 physical qubits to implement the algorithm logic, and 5,780,160 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 1,536$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 3,184$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 64,361,022 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 193,083,066.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 7 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 64,361,022 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 257,444,088 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 1,784 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{257,444,088 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 1,274,348,235,600,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 257,444,088 T states, the 1,784 copies of the T factory are repeatedly invoked 144,308 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 770,528 are the product of the 3,184 logical qubits after layout and the 242 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 1,784 in parallel, therefore we need $5,780,160 = 3,240 \\cdot 1,784$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 3,184 logical qubits and the total cycle count 193,083,066."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 257,444,088."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000007319733481519155)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{11 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 6,600,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 242."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.75e-9."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 3,184 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2808648000,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 131072000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 131058288,
                        "runtime": 1621897754400,
                        "rqops": 379047620,
                        "breakdown": {
                            "algorithmicLogicalQubits": 3184,
                            "algorithmicLogicalDepth": 193083066,
                            "logicalDepth": 193083066,
                            "numTstates": 257444088,
                            "clockFrequency": 119047.61904761905,
                            "numTfactories": 7125,
                            "numTfactoryRuns": 36133,
                            "physicalQubitsForTfactories": 128250000,
                            "physicalQubitsForAlgorithm": 2808288,
                            "requiredLogicalQubitErrorRate": 7.319733481519155e-13,
                            "requiredLogicalTstateErrorRate": 1.7479523553867743e-09,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "27 mins",
                        "rqops": "379.05M",
                        "physicalQubits": "131.06M",
                        "algorithmicLogicalQubits": "3.18k",
                        "algorithmicLogicalDepth": "193.08M",
                        "logicalDepth": "193.08M",
                        "numTstates": "257.44M",
                        "numTfactories": "7.12k",
                        "numTfactoryRuns": "36.13k",
                        "physicalQubitsForAlgorithm": "2.81M",
                        "physicalQubitsForTfactories": "128.25M",
                        "physicalQubitsForTfactoriesPercentage": "97.86 %",
                        "requiredLogicalQubitErrorRate": "7.32e-13",
                        "requiredLogicalTstateErrorRate": "1.75e-9",
                        "physicalQubitsPerLogicalQubit": "882",
                        "logicalCycleTime": "8 microsecs",
                        "clockFrequency": "119.05k",
                        "logicalErrorRate": "3.00e-13",
                        "tfactoryPhysicalQubits": "18.00k",
                        "tfactoryRuntime": "101 microsecs",
                        "numInputTstates": "270",
                        "numUnitsPerRound": "18, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "5, 17",
                        "physicalQubitsPerRound": "18.00k, 17.92k",
                        "tfactoryRuntimePerRound": "26 microsecs, 75 microsecs",
                        "tstateLogicalErrorRate": "5.51e-10",
                        "logicalCountsNumQubits": "1.54k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "64.36M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "131072000"
                    },
                    "logicalQubit": {
                        "codeDistance": 21,
                        "physicalQubits": 882,
                        "logicalCycleTime": 8400,
                        "logicalErrorRate": 3.000000000000003e-13
                    },
                    "tfactory": {
                        "physicalQubits": 18000,
                        "runtime": 100800,
                        "numTstates": 1,
                        "numInputTstates": 270,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            18,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            5,
                            17
                        ],
                        "physicalQubitsPerRound": [
                            18000,
                            17918
                        ],
                        "runtimePerRound": [
                            26000,
                            74800
                        ],
                        "logicalErrorRate": 5.513926534736261e-10
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 1536,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 64361022,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (8,400 nanosecs) multiplied by the 193,083,066 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 100,800 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (3,184) (with a logical error rate of 7.32e-13) multiplied by the clock frequency (119,047.62), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 2,808,288 physical qubits to implement the algorithm logic, and 128,250,000 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 1,536$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 3,184$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 64,361,022 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 193,083,066.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 8 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 64,361,022 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 257,444,088 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 7,125 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{257,444,088 \\cdot 100,800\\;\\text{ns}}{1 \\cdot 1,621,897,754,400\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 257,444,088 T states, the 7,125 copies of the T factory are repeatedly invoked 36,133 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 2,808,288 are the product of the 3,184 logical qubits after layout and the 882 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 18,000 physical qubits and we run 7,125 in parallel, therefore we need $128,250,000 = 18,000 \\cdot 7,125$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 3,184 logical qubits and the total cycle count 193,083,066."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 257,444,088."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000007319733481519155)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{21 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 8,400 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 882."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 270 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 5.51e-10."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.75e-9."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 3,184 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2808648000,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 13107200,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 13105208,
                        "runtime": 1274348235600000,
                        "rqops": 482425,
                        "breakdown": {
                            "algorithmicLogicalQubits": 3184,
                            "algorithmicLogicalDepth": 193083066,
                            "logicalDepth": 193083066,
                            "numTstates": 257444088,
                            "clockFrequency": 151.5151515151515,
                            "numTfactories": 3807,
                            "numTfactoryRuns": 67624,
                            "physicalQubitsForTfactories": 12334680,
                            "physicalQubitsForAlgorithm": 770528,
                            "requiredLogicalQubitErrorRate": 7.319733481519155e-13,
                            "requiredLogicalTstateErrorRate": 1.7479523553867743e-09,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "15 days",
                        "rqops": "482.43k",
                        "physicalQubits": "13.11M",
                        "algorithmicLogicalQubits": "3.18k",
                        "algorithmicLogicalDepth": "193.08M",
                        "logicalDepth": "193.08M",
                        "numTstates": "257.44M",
                        "numTfactories": "3.81k",
                        "numTfactoryRuns": "67.62k",
                        "physicalQubitsForAlgorithm": "770.53k",
                        "physicalQubitsForTfactories": "12.33M",
                        "physicalQubitsForTfactoriesPercentage": "94.12 %",
                        "requiredLogicalQubitErrorRate": "7.32e-13",
                        "requiredLogicalTstateErrorRate": "1.75e-9",
                        "physicalQubitsPerLogicalQubit": "242",
                        "logicalCycleTime": "7 millisecs",
                        "clockFrequency": "152",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "1.54k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "64.36M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "13107200"
                    },
                    "logicalQubit": {
                        "codeDistance": 11,
                        "physicalQubits": 242,
                        "logicalCycleTime": 6600000,
                        "logicalErrorRate": 3e-14
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 1536,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 64361022,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (6,600,000 nanosecs) multiplied by the 193,083,066 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (3,184) (with a logical error rate of 7.32e-13) multiplied by the clock frequency (151.52), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 770,528 physical qubits to implement the algorithm logic, and 12,334,680 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 1,536$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 3,184$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 64,361,022 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 193,083,066.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 7 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 64,361,022 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 257,444,088 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 3,807 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{257,444,088 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 1,274,348,235,600,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 257,444,088 T states, the 3,807 copies of the T factory are repeatedly invoked 67,624 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 770,528 are the product of the 3,184 logical qubits after layout and the 242 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 3,807 in parallel, therefore we need $12,334,680 = 3,240 \\cdot 3,807$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 3,184 logical qubits and the total cycle count 193,083,066."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 257,444,088."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000007319733481519155)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{11 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 6,600,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 242."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.75e-9."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 3,184 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2871763200,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 262144000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 262134288,
                        "runtime": 1621897754400,
                        "rqops": 379047620,
                        "breakdown": {
                            "algorithmicLogicalQubits": 3184,
                            "algorithmicLogicalDepth": 193083066,
                            "logicalDepth": 193083066,
                            "numTstates": 257444088,
                            "clockFrequency": 119047.61904761905,
                            "numTfactories": 14407,
                            "numTfactoryRuns": 17870,
                            "physicalQubitsForTfactories": 259326000,
                            "physicalQubitsForAlgorithm": 2808288,
                            "requiredLogicalQubitErrorRate": 7.319733481519155e-13,
                            "requiredLogicalTstateErrorRate": 1.7479523553867743e-09,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "27 mins",
                        "rqops": "379.05M",
                        "physicalQubits": "262.13M",
                        "algorithmicLogicalQubits": "3.18k",
                        "algorithmicLogicalDepth": "193.08M",
                        "logicalDepth": "193.08M",
                        "numTstates": "257.44M",
                        "numTfactories": "14.41k",
                        "numTfactoryRuns": "17.87k",
                        "physicalQubitsForAlgorithm": "2.81M",
                        "physicalQubitsForTfactories": "259.33M",
                        "physicalQubitsForTfactoriesPercentage": "98.93 %",
                        "requiredLogicalQubitErrorRate": "7.32e-13",
                        "requiredLogicalTstateErrorRate": "1.75e-9",
                        "physicalQubitsPerLogicalQubit": "882",
                        "logicalCycleTime": "8 microsecs",
                        "clockFrequency": "119.05k",
                        "logicalErrorRate": "3.00e-13",
                        "tfactoryPhysicalQubits": "18.00k",
                        "tfactoryRuntime": "101 microsecs",
                        "numInputTstates": "270",
                        "numUnitsPerRound": "18, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "5, 17",
                        "physicalQubitsPerRound": "18.00k, 17.92k",
                        "tfactoryRuntimePerRound": "26 microsecs, 75 microsecs",
                        "tstateLogicalErrorRate": "5.51e-10",
                        "logicalCountsNumQubits": "1.54k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "64.36M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "262144000"
                    },
                    "logicalQubit": {
                        "codeDistance": 21,
                        "physicalQubits": 882,
                        "logicalCycleTime": 8400,
                        "logicalErrorRate": 3.000000000000003e-13
                    },
                    "tfactory": {
                        "physicalQubits": 18000,
                        "runtime": 100800,
                        "numTstates": 1,
                        "numInputTstates": 270,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            18,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            5,
                            17
                        ],
                        "physicalQubitsPerRound": [
                            18000,
                            17918
                        ],
                        "runtimePerRound": [
                            26000,
                            74800
                        ],
                        "logicalErrorRate": 5.513926534736261e-10
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 1536,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 64361022,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (8,400 nanosecs) multiplied by the 193,083,066 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 100,800 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (3,184) (with a logical error rate of 7.32e-13) multiplied by the clock frequency (119,047.62), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 2,808,288 physical qubits to implement the algorithm logic, and 259,326,000 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 1,536$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 3,184$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 64,361,022 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 193,083,066.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 8 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 64,361,022 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 257,444,088 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 14,407 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{257,444,088 \\cdot 100,800\\;\\text{ns}}{1 \\cdot 1,621,897,754,400\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 257,444,088 T states, the 14,407 copies of the T factory are repeatedly invoked 17,870 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 2,808,288 are the product of the 3,184 logical qubits after layout and the 882 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 18,000 physical qubits and we run 14,407 in parallel, therefore we need $259,326,000 = 18,000 \\cdot 14,407$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 3,184 logical qubits and the total cycle count 193,083,066."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 257,444,088."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000007319733481519155)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{21 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 8,400 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 882."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 270 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 5.51e-10."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.75e-9."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 3,184 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2871763200,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 26214400,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 26214248,
                        "runtime": 1274348235600000,
                        "rqops": 482425,
                        "breakdown": {
                            "algorithmicLogicalQubits": 3184,
                            "algorithmicLogicalDepth": 193083066,
                            "logicalDepth": 193083066,
                            "numTstates": 257444088,
                            "clockFrequency": 151.5151515151515,
                            "numTfactories": 7853,
                            "numTfactoryRuns": 32783,
                            "physicalQubitsForTfactories": 25443720,
                            "physicalQubitsForAlgorithm": 770528,
                            "requiredLogicalQubitErrorRate": 7.319733481519155e-13,
                            "requiredLogicalTstateErrorRate": 1.7479523553867743e-09,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "15 days",
                        "rqops": "482.43k",
                        "physicalQubits": "26.21M",
                        "algorithmicLogicalQubits": "3.18k",
                        "algorithmicLogicalDepth": "193.08M",
                        "logicalDepth": "193.08M",
                        "numTstates": "257.44M",
                        "numTfactories": "7.85k",
                        "numTfactoryRuns": "32.78k",
                        "physicalQubitsForAlgorithm": "770.53k",
                        "physicalQubitsForTfactories": "25.44M",
                        "physicalQubitsForTfactoriesPercentage": "97.06 %",
                        "requiredLogicalQubitErrorRate": "7.32e-13",
                        "requiredLogicalTstateErrorRate": "1.75e-9",
                        "physicalQubitsPerLogicalQubit": "242",
                        "logicalCycleTime": "7 millisecs",
                        "clockFrequency": "152",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "1.54k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "64.36M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "26214400"
                    },
                    "logicalQubit": {
                        "codeDistance": 11,
                        "physicalQubits": 242,
                        "logicalCycleTime": 6600000,
                        "logicalErrorRate": 3e-14
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 1536,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 64361022,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (6,600,000 nanosecs) multiplied by the 193,083,066 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (3,184) (with a logical error rate of 7.32e-13) multiplied by the clock frequency (151.52), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 770,528 physical qubits to implement the algorithm logic, and 25,443,720 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 1,536$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 3,184$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 64,361,022 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 193,083,066.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 7 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 64,361,022 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 257,444,088 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 7,853 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{257,444,088 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 1,274,348,235,600,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 257,444,088 T states, the 7,853 copies of the T factory are repeatedly invoked 32,783 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 770,528 are the product of the 3,184 logical qubits after layout and the 242 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 7,853 in parallel, therefore we need $25,443,720 = 3,240 \\cdot 7,853$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 3,184 logical qubits and the total cycle count 193,083,066."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 257,444,088."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000007319733481519155)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{11 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 6,600,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 242."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.75e-9."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 3,184 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2934878400,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 524288000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 524286288,
                        "runtime": 1621897754400,
                        "rqops": 379047620,
                        "breakdown": {
                            "algorithmicLogicalQubits": 3184,
                            "algorithmicLogicalDepth": 193083066,
                            "logicalDepth": 193083066,
                            "numTstates": 257444088,
                            "clockFrequency": 119047.61904761905,
                            "numTfactories": 28971,
                            "numTfactoryRuns": 8887,
                            "physicalQubitsForTfactories": 521478000,
                            "physicalQubitsForAlgorithm": 2808288,
                            "requiredLogicalQubitErrorRate": 7.319733481519155e-13,
                            "requiredLogicalTstateErrorRate": 1.7479523553867743e-09,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "27 mins",
                        "rqops": "379.05M",
                        "physicalQubits": "524.29M",
                        "algorithmicLogicalQubits": "3.18k",
                        "algorithmicLogicalDepth": "193.08M",
                        "logicalDepth": "193.08M",
                        "numTstates": "257.44M",
                        "numTfactories": "28.97k",
                        "numTfactoryRuns": "8.89k",
                        "physicalQubitsForAlgorithm": "2.81M",
                        "physicalQubitsForTfactories": "521.48M",
                        "physicalQubitsForTfactoriesPercentage": "99.46 %",
                        "requiredLogicalQubitErrorRate": "7.32e-13",
                        "requiredLogicalTstateErrorRate": "1.75e-9",
                        "physicalQubitsPerLogicalQubit": "882",
                        "logicalCycleTime": "8 microsecs",
                        "clockFrequency": "119.05k",
                        "logicalErrorRate": "3.00e-13",
                        "tfactoryPhysicalQubits": "18.00k",
                        "tfactoryRuntime": "101 microsecs",
                        "numInputTstates": "270",
                        "numUnitsPerRound": "18, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "5, 17",
                        "physicalQubitsPerRound": "18.00k, 17.92k",
                        "tfactoryRuntimePerRound": "26 microsecs, 75 microsecs",
                        "tstateLogicalErrorRate": "5.51e-10",
                        "logicalCountsNumQubits": "1.54k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "64.36M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "524288000"
                    },
                    "logicalQubit": {
                        "codeDistance": 21,
                        "physicalQubits": 882,
                        "logicalCycleTime": 8400,
                        "logicalErrorRate": 3.000000000000003e-13
                    },
                    "tfactory": {
                        "physicalQubits": 18000,
                        "runtime": 100800,
                        "numTstates": 1,
                        "numInputTstates": 270,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            18,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            5,
                            17
                        ],
                        "physicalQubitsPerRound": [
                            18000,
                            17918
                        ],
                        "runtimePerRound": [
                            26000,
                            74800
                        ],
                        "logicalErrorRate": 5.513926534736261e-10
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 1536,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 64361022,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (8,400 nanosecs) multiplied by the 193,083,066 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 100,800 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (3,184) (with a logical error rate of 7.32e-13) multiplied by the clock frequency (119,047.62), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 2,808,288 physical qubits to implement the algorithm logic, and 521,478,000 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 1,536$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 3,184$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 64,361,022 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 193,083,066.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 8 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 64,361,022 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 257,444,088 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 28,971 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{257,444,088 \\cdot 100,800\\;\\text{ns}}{1 \\cdot 1,621,897,754,400\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 257,444,088 T states, the 28,971 copies of the T factory are repeatedly invoked 8,887 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 2,808,288 are the product of the 3,184 logical qubits after layout and the 882 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 18,000 physical qubits and we run 28,971 in parallel, therefore we need $521,478,000 = 18,000 \\cdot 28,971$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 3,184 logical qubits and the total cycle count 193,083,066."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 257,444,088."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000007319733481519155)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{21 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 8,400 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 882."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 270 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 5.51e-10."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.75e-9."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 3,184 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2934878400,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 52428800,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 52425848,
                        "runtime": 1274348235600000,
                        "rqops": 482425,
                        "breakdown": {
                            "algorithmicLogicalQubits": 3184,
                            "algorithmicLogicalDepth": 193083066,
                            "logicalDepth": 193083066,
                            "numTstates": 257444088,
                            "clockFrequency": 151.5151515151515,
                            "numTfactories": 15943,
                            "numTfactoryRuns": 16148,
                            "physicalQubitsForTfactories": 51655320,
                            "physicalQubitsForAlgorithm": 770528,
                            "requiredLogicalQubitErrorRate": 7.319733481519155e-13,
                            "requiredLogicalTstateErrorRate": 1.7479523553867743e-09,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "15 days",
                        "rqops": "482.43k",
                        "physicalQubits": "52.43M",
                        "algorithmicLogicalQubits": "3.18k",
                        "algorithmicLogicalDepth": "193.08M",
                        "logicalDepth": "193.08M",
                        "numTstates": "257.44M",
                        "numTfactories": "15.94k",
                        "numTfactoryRuns": "16.15k",
                        "physicalQubitsForAlgorithm": "770.53k",
                        "physicalQubitsForTfactories": "51.66M",
                        "physicalQubitsForTfactoriesPercentage": "98.53 %",
                        "requiredLogicalQubitErrorRate": "7.32e-13",
                        "requiredLogicalTstateErrorRate": "1.75e-9",
                        "physicalQubitsPerLogicalQubit": "242",
                        "logicalCycleTime": "7 millisecs",
                        "clockFrequency": "152",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "1.54k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "64.36M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "52428800"
                    },
                    "logicalQubit": {
                        "codeDistance": 11,
                        "physicalQubits": 242,
                        "logicalCycleTime": 6600000,
                        "logicalErrorRate": 3e-14
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 1536,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 64361022,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (6,600,000 nanosecs) multiplied by the 193,083,066 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (3,184) (with a logical error rate of 7.32e-13) multiplied by the clock frequency (151.52), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 770,528 physical qubits to implement the algorithm logic, and 51,655,320 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 1,536$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 3,184$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 64,361,022 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 193,083,066.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 7 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 64,361,022 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 257,444,088 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 15,943 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{257,444,088 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 1,274,348,235,600,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 257,444,088 T states, the 15,943 copies of the T factory are repeatedly invoked 16,148 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 770,528 are the product of the 3,184 logical qubits after layout and the 242 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 15,943 in parallel, therefore we need $51,655,320 = 3,240 \\cdot 15,943$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 3,184 logical qubits and the total cycle count 193,083,066."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 257,444,088."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000007319733481519155)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{11 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 6,600,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 242."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.75e-9."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 3,184 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            }
        ]
    },
    {
        "protocol": "RSA-1024",
        "threats": [
            {
                "timestamp": 2556187200,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 8192000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 8166916,
                        "runtime": 10661742828000,
                        "rqops": 685000000,
                        "breakdown": {
                            "algorithmicLogicalQubits": 6302,
                            "algorithmicLogicalDepth": 1158885090,
                            "logicalDepth": 1158885090,
                            "numTstates": 1545180120,
                            "clockFrequency": 108695.65217391304,
                            "numTfactories": 45,
                            "numTfactoryRuns": 34337336,
                            "physicalQubitsForTfactories": 1499400,
                            "physicalQubitsForAlgorithm": 6667516,
                            "requiredLogicalQubitErrorRate": 6.16160338105412e-14,
                            "requiredLogicalTstateErrorRate": 2.9122818380552293e-10,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "3 hours",
                        "rqops": "685.00M",
                        "physicalQubits": "8.17M",
                        "algorithmicLogicalQubits": "6.30k",
                        "algorithmicLogicalDepth": "1.16G",
                        "logicalDepth": "1.16G",
                        "numTstates": "1.55G",
                        "numTfactories": "45",
                        "numTfactoryRuns": "34.34M",
                        "physicalQubitsForAlgorithm": "6.67M",
                        "physicalQubitsForTfactories": "1.50M",
                        "physicalQubitsForTfactoriesPercentage": "18.36 %",
                        "requiredLogicalQubitErrorRate": "6.16e-14",
                        "requiredLogicalTstateErrorRate": "2.91e-10",
                        "physicalQubitsPerLogicalQubit": "1.06k",
                        "logicalCycleTime": "9 microsecs",
                        "clockFrequency": "108.70k",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "111 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 17",
                        "physicalQubitsPerRound": "33.32k, 17.92k",
                        "tfactoryRuntimePerRound": "36 microsecs, 75 microsecs",
                        "tstateLogicalErrorRate": "2.13e-10",
                        "logicalCountsNumQubits": "3.07k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "386.30M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "8192000"
                    },
                    "logicalQubit": {
                        "codeDistance": 23,
                        "physicalQubits": 1058,
                        "logicalCycleTime": 9200,
                        "logicalErrorRate": 3.000000000000004e-14
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 111200,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            17
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            17918
                        ],
                        "runtimePerRound": [
                            36400,
                            74800
                        ],
                        "logicalErrorRate": 2.133398959469633e-10
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 3072,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 386295030,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (9,200 nanosecs) multiplied by the 1,158,885,090 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 111,200 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (6,302) (with a logical error rate of 6.16e-14) multiplied by the clock frequency (108,695.65), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 6,667,516 physical qubits to implement the algorithm logic, and 1,499,400 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 3,072$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 6,302$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 386,295,030 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 1,158,885,090.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 9 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 386,295,030 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 1,545,180,120 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 45 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{1,545,180,120 \\cdot 111,200\\;\\text{ns}}{1 \\cdot 10,661,742,828,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 1,545,180,120 T states, the 45 copies of the T factory are repeatedly invoked 34,337,336 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 6,667,516 are the product of the 6,302 logical qubits after layout and the 1,058 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 45 in parallel, therefore we need $1,499,400 = 33,320 \\cdot 45$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 6,302 logical qubits and the total cycle count 1,158,885,090."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 1,545,180,120."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000000616160338105412)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{23 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 9,200 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,058."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.13e-10."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 2.91e-10."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 6,302 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2619302400,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 16384000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 16363636,
                        "runtime": 10661742828000,
                        "rqops": 685000000,
                        "breakdown": {
                            "algorithmicLogicalQubits": 6302,
                            "algorithmicLogicalDepth": 1158885090,
                            "logicalDepth": 1158885090,
                            "numTstates": 1545180120,
                            "clockFrequency": 108695.65217391304,
                            "numTfactories": 291,
                            "numTfactoryRuns": 5309898,
                            "physicalQubitsForTfactories": 9696120,
                            "physicalQubitsForAlgorithm": 6667516,
                            "requiredLogicalQubitErrorRate": 6.16160338105412e-14,
                            "requiredLogicalTstateErrorRate": 2.9122818380552293e-10,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "3 hours",
                        "rqops": "685.00M",
                        "physicalQubits": "16.36M",
                        "algorithmicLogicalQubits": "6.30k",
                        "algorithmicLogicalDepth": "1.16G",
                        "logicalDepth": "1.16G",
                        "numTstates": "1.55G",
                        "numTfactories": "291",
                        "numTfactoryRuns": "5.31M",
                        "physicalQubitsForAlgorithm": "6.67M",
                        "physicalQubitsForTfactories": "9.70M",
                        "physicalQubitsForTfactoriesPercentage": "59.25 %",
                        "requiredLogicalQubitErrorRate": "6.16e-14",
                        "requiredLogicalTstateErrorRate": "2.91e-10",
                        "physicalQubitsPerLogicalQubit": "1.06k",
                        "logicalCycleTime": "9 microsecs",
                        "clockFrequency": "108.70k",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "111 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 17",
                        "physicalQubitsPerRound": "33.32k, 17.92k",
                        "tfactoryRuntimePerRound": "36 microsecs, 75 microsecs",
                        "tstateLogicalErrorRate": "2.13e-10",
                        "logicalCountsNumQubits": "3.07k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "386.30M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "16384000"
                    },
                    "logicalQubit": {
                        "codeDistance": 23,
                        "physicalQubits": 1058,
                        "logicalCycleTime": 9200,
                        "logicalErrorRate": 3.000000000000004e-14
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 111200,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            17
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            17918
                        ],
                        "runtimePerRound": [
                            36400,
                            74800
                        ],
                        "logicalErrorRate": 2.133398959469633e-10
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 3072,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 386295030,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (9,200 nanosecs) multiplied by the 1,158,885,090 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 111,200 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (6,302) (with a logical error rate of 6.16e-14) multiplied by the clock frequency (108,695.65), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 6,667,516 physical qubits to implement the algorithm logic, and 9,696,120 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 3,072$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 6,302$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 386,295,030 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 1,158,885,090.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 9 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 386,295,030 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 1,545,180,120 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 291 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{1,545,180,120 \\cdot 111,200\\;\\text{ns}}{1 \\cdot 10,661,742,828,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 1,545,180,120 T states, the 291 copies of the T factory are repeatedly invoked 5,309,898 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 6,667,516 are the product of the 6,302 logical qubits after layout and the 1,058 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 291 in parallel, therefore we need $9,696,120 = 33,320 \\cdot 291$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 6,302 logical qubits and the total cycle count 1,158,885,090."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 1,545,180,120."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000000616160338105412)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{23 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 9,200 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,058."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.13e-10."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 2.91e-10."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 6,302 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2619302400,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 1638400,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 1635244,
                        "runtime": 7648641594000000,
                        "rqops": 954849,
                        "breakdown": {
                            "algorithmicLogicalQubits": 6302,
                            "algorithmicLogicalDepth": 1158885090,
                            "logicalDepth": 1158885090,
                            "numTstates": 1545180120,
                            "clockFrequency": 151.5151515151515,
                            "numTfactories": 34,
                            "numTfactoryRuns": 45446475,
                            "physicalQubitsForTfactories": 110160,
                            "physicalQubitsForAlgorithm": 1525084,
                            "requiredLogicalQubitErrorRate": 6.16160338105412e-14,
                            "requiredLogicalTstateErrorRate": 2.9122818380552293e-10,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "89 days",
                        "rqops": "954.85k",
                        "physicalQubits": "1.64M",
                        "algorithmicLogicalQubits": "6.30k",
                        "algorithmicLogicalDepth": "1.16G",
                        "logicalDepth": "1.16G",
                        "numTstates": "1.55G",
                        "numTfactories": "34",
                        "numTfactoryRuns": "45.45M",
                        "physicalQubitsForAlgorithm": "1.53M",
                        "physicalQubitsForTfactories": "110.16k",
                        "physicalQubitsForTfactoriesPercentage": "6.74 %",
                        "requiredLogicalQubitErrorRate": "6.16e-14",
                        "requiredLogicalTstateErrorRate": "2.91e-10",
                        "physicalQubitsPerLogicalQubit": "242",
                        "logicalCycleTime": "7 millisecs",
                        "clockFrequency": "152",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "3.07k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "386.30M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "1638400"
                    },
                    "logicalQubit": {
                        "codeDistance": 11,
                        "physicalQubits": 242,
                        "logicalCycleTime": 6600000,
                        "logicalErrorRate": 3e-14
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 3072,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 386295030,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (6,600,000 nanosecs) multiplied by the 1,158,885,090 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (6,302) (with a logical error rate of 6.16e-14) multiplied by the clock frequency (151.52), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 1,525,084 physical qubits to implement the algorithm logic, and 110,160 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 3,072$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 6,302$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 386,295,030 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 1,158,885,090.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 7 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 386,295,030 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 1,545,180,120 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 34 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{1,545,180,120 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 7,648,641,594,000,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 1,545,180,120 T states, the 34 copies of the T factory are repeatedly invoked 45,446,475 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 1,525,084 are the product of the 6,302 logical qubits after layout and the 242 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 34 in parallel, therefore we need $110,160 = 3,240 \\cdot 34$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 6,302 logical qubits and the total cycle count 1,158,885,090."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 1,545,180,120."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000000616160338105412)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{11 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 6,600,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 242."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 2.91e-10."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 6,302 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2682417600,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 32768000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 32757076,
                        "runtime": 10661742828000,
                        "rqops": 685000000,
                        "breakdown": {
                            "algorithmicLogicalQubits": 6302,
                            "algorithmicLogicalDepth": 1158885090,
                            "logicalDepth": 1158885090,
                            "numTstates": 1545180120,
                            "clockFrequency": 108695.65217391304,
                            "numTfactories": 783,
                            "numTfactoryRuns": 1973411,
                            "physicalQubitsForTfactories": 26089560,
                            "physicalQubitsForAlgorithm": 6667516,
                            "requiredLogicalQubitErrorRate": 6.16160338105412e-14,
                            "requiredLogicalTstateErrorRate": 2.9122818380552293e-10,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "3 hours",
                        "rqops": "685.00M",
                        "physicalQubits": "32.76M",
                        "algorithmicLogicalQubits": "6.30k",
                        "algorithmicLogicalDepth": "1.16G",
                        "logicalDepth": "1.16G",
                        "numTstates": "1.55G",
                        "numTfactories": "783",
                        "numTfactoryRuns": "1.97M",
                        "physicalQubitsForAlgorithm": "6.67M",
                        "physicalQubitsForTfactories": "26.09M",
                        "physicalQubitsForTfactoriesPercentage": "79.65 %",
                        "requiredLogicalQubitErrorRate": "6.16e-14",
                        "requiredLogicalTstateErrorRate": "2.91e-10",
                        "physicalQubitsPerLogicalQubit": "1.06k",
                        "logicalCycleTime": "9 microsecs",
                        "clockFrequency": "108.70k",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "111 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 17",
                        "physicalQubitsPerRound": "33.32k, 17.92k",
                        "tfactoryRuntimePerRound": "36 microsecs, 75 microsecs",
                        "tstateLogicalErrorRate": "2.13e-10",
                        "logicalCountsNumQubits": "3.07k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "386.30M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "32768000"
                    },
                    "logicalQubit": {
                        "codeDistance": 23,
                        "physicalQubits": 1058,
                        "logicalCycleTime": 9200,
                        "logicalErrorRate": 3.000000000000004e-14
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 111200,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            17
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            17918
                        ],
                        "runtimePerRound": [
                            36400,
                            74800
                        ],
                        "logicalErrorRate": 2.133398959469633e-10
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 3072,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 386295030,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (9,200 nanosecs) multiplied by the 1,158,885,090 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 111,200 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (6,302) (with a logical error rate of 6.16e-14) multiplied by the clock frequency (108,695.65), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 6,667,516 physical qubits to implement the algorithm logic, and 26,089,560 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 3,072$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 6,302$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 386,295,030 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 1,158,885,090.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 9 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 386,295,030 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 1,545,180,120 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 783 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{1,545,180,120 \\cdot 111,200\\;\\text{ns}}{1 \\cdot 10,661,742,828,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 1,545,180,120 T states, the 783 copies of the T factory are repeatedly invoked 1,973,411 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 6,667,516 are the product of the 6,302 logical qubits after layout and the 1,058 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 783 in parallel, therefore we need $26,089,560 = 33,320 \\cdot 783$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 6,302 logical qubits and the total cycle count 1,158,885,090."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 1,545,180,120."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000000616160338105412)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{23 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 9,200 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,058."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.13e-10."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 2.91e-10."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 6,302 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2682417600,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 3276800,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 3274684,
                        "runtime": 7648641594000000,
                        "rqops": 954849,
                        "breakdown": {
                            "algorithmicLogicalQubits": 6302,
                            "algorithmicLogicalDepth": 1158885090,
                            "logicalDepth": 1158885090,
                            "numTstates": 1545180120,
                            "clockFrequency": 151.5151515151515,
                            "numTfactories": 540,
                            "numTfactoryRuns": 2861445,
                            "physicalQubitsForTfactories": 1749600,
                            "physicalQubitsForAlgorithm": 1525084,
                            "requiredLogicalQubitErrorRate": 6.16160338105412e-14,
                            "requiredLogicalTstateErrorRate": 2.9122818380552293e-10,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "89 days",
                        "rqops": "954.85k",
                        "physicalQubits": "3.27M",
                        "algorithmicLogicalQubits": "6.30k",
                        "algorithmicLogicalDepth": "1.16G",
                        "logicalDepth": "1.16G",
                        "numTstates": "1.55G",
                        "numTfactories": "540",
                        "numTfactoryRuns": "2.86M",
                        "physicalQubitsForAlgorithm": "1.53M",
                        "physicalQubitsForTfactories": "1.75M",
                        "physicalQubitsForTfactoriesPercentage": "53.43 %",
                        "requiredLogicalQubitErrorRate": "6.16e-14",
                        "requiredLogicalTstateErrorRate": "2.91e-10",
                        "physicalQubitsPerLogicalQubit": "242",
                        "logicalCycleTime": "7 millisecs",
                        "clockFrequency": "152",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "3.07k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "386.30M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "3276800"
                    },
                    "logicalQubit": {
                        "codeDistance": 11,
                        "physicalQubits": 242,
                        "logicalCycleTime": 6600000,
                        "logicalErrorRate": 3e-14
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 3072,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 386295030,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (6,600,000 nanosecs) multiplied by the 1,158,885,090 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (6,302) (with a logical error rate of 6.16e-14) multiplied by the clock frequency (151.52), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 1,525,084 physical qubits to implement the algorithm logic, and 1,749,600 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 3,072$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 6,302$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 386,295,030 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 1,158,885,090.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 7 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 386,295,030 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 1,545,180,120 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 540 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{1,545,180,120 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 7,648,641,594,000,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 1,545,180,120 T states, the 540 copies of the T factory are repeatedly invoked 2,861,445 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 1,525,084 are the product of the 6,302 logical qubits after layout and the 242 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 540 in parallel, therefore we need $1,749,600 = 3,240 \\cdot 540$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 6,302 logical qubits and the total cycle count 1,158,885,090."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 1,545,180,120."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000000616160338105412)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{11 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 6,600,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 242."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 2.91e-10."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 6,302 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2745532800,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 65536000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 65510636,
                        "runtime": 10661742828000,
                        "rqops": 685000000,
                        "breakdown": {
                            "algorithmicLogicalQubits": 6302,
                            "algorithmicLogicalDepth": 1158885090,
                            "logicalDepth": 1158885090,
                            "numTstates": 1545180120,
                            "clockFrequency": 108695.65217391304,
                            "numTfactories": 1766,
                            "numTfactoryRuns": 874961,
                            "physicalQubitsForTfactories": 58843120,
                            "physicalQubitsForAlgorithm": 6667516,
                            "requiredLogicalQubitErrorRate": 6.16160338105412e-14,
                            "requiredLogicalTstateErrorRate": 2.9122818380552293e-10,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "3 hours",
                        "rqops": "685.00M",
                        "physicalQubits": "65.51M",
                        "algorithmicLogicalQubits": "6.30k",
                        "algorithmicLogicalDepth": "1.16G",
                        "logicalDepth": "1.16G",
                        "numTstates": "1.55G",
                        "numTfactories": "1.77k",
                        "numTfactoryRuns": "874.96k",
                        "physicalQubitsForAlgorithm": "6.67M",
                        "physicalQubitsForTfactories": "58.84M",
                        "physicalQubitsForTfactoriesPercentage": "89.82 %",
                        "requiredLogicalQubitErrorRate": "6.16e-14",
                        "requiredLogicalTstateErrorRate": "2.91e-10",
                        "physicalQubitsPerLogicalQubit": "1.06k",
                        "logicalCycleTime": "9 microsecs",
                        "clockFrequency": "108.70k",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "111 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 17",
                        "physicalQubitsPerRound": "33.32k, 17.92k",
                        "tfactoryRuntimePerRound": "36 microsecs, 75 microsecs",
                        "tstateLogicalErrorRate": "2.13e-10",
                        "logicalCountsNumQubits": "3.07k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "386.30M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "65536000"
                    },
                    "logicalQubit": {
                        "codeDistance": 23,
                        "physicalQubits": 1058,
                        "logicalCycleTime": 9200,
                        "logicalErrorRate": 3.000000000000004e-14
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 111200,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            17
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            17918
                        ],
                        "runtimePerRound": [
                            36400,
                            74800
                        ],
                        "logicalErrorRate": 2.133398959469633e-10
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 3072,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 386295030,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (9,200 nanosecs) multiplied by the 1,158,885,090 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 111,200 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (6,302) (with a logical error rate of 6.16e-14) multiplied by the clock frequency (108,695.65), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 6,667,516 physical qubits to implement the algorithm logic, and 58,843,120 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 3,072$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 6,302$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 386,295,030 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 1,158,885,090.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 9 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 386,295,030 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 1,545,180,120 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 1,766 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{1,545,180,120 \\cdot 111,200\\;\\text{ns}}{1 \\cdot 10,661,742,828,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 1,545,180,120 T states, the 1,766 copies of the T factory are repeatedly invoked 874,961 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 6,667,516 are the product of the 6,302 logical qubits after layout and the 1,058 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 1,766 in parallel, therefore we need $58,843,120 = 33,320 \\cdot 1,766$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 6,302 logical qubits and the total cycle count 1,158,885,090."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 1,545,180,120."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000000616160338105412)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{23 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 9,200 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,058."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.13e-10."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 2.91e-10."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 6,302 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2745532800,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 6553600,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 6553564,
                        "runtime": 7648641594000000,
                        "rqops": 954849,
                        "breakdown": {
                            "algorithmicLogicalQubits": 6302,
                            "algorithmicLogicalDepth": 1158885090,
                            "logicalDepth": 1158885090,
                            "numTstates": 1545180120,
                            "clockFrequency": 151.5151515151515,
                            "numTfactories": 1552,
                            "numTfactoryRuns": 995606,
                            "physicalQubitsForTfactories": 5028480,
                            "physicalQubitsForAlgorithm": 1525084,
                            "requiredLogicalQubitErrorRate": 6.16160338105412e-14,
                            "requiredLogicalTstateErrorRate": 2.9122818380552293e-10,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "89 days",
                        "rqops": "954.85k",
                        "physicalQubits": "6.55M",
                        "algorithmicLogicalQubits": "6.30k",
                        "algorithmicLogicalDepth": "1.16G",
                        "logicalDepth": "1.16G",
                        "numTstates": "1.55G",
                        "numTfactories": "1.55k",
                        "numTfactoryRuns": "995.61k",
                        "physicalQubitsForAlgorithm": "1.53M",
                        "physicalQubitsForTfactories": "5.03M",
                        "physicalQubitsForTfactoriesPercentage": "76.73 %",
                        "requiredLogicalQubitErrorRate": "6.16e-14",
                        "requiredLogicalTstateErrorRate": "2.91e-10",
                        "physicalQubitsPerLogicalQubit": "242",
                        "logicalCycleTime": "7 millisecs",
                        "clockFrequency": "152",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "3.07k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "386.30M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "6553600"
                    },
                    "logicalQubit": {
                        "codeDistance": 11,
                        "physicalQubits": 242,
                        "logicalCycleTime": 6600000,
                        "logicalErrorRate": 3e-14
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 3072,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 386295030,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (6,600,000 nanosecs) multiplied by the 1,158,885,090 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (6,302) (with a logical error rate of 6.16e-14) multiplied by the clock frequency (151.52), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 1,525,084 physical qubits to implement the algorithm logic, and 5,028,480 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 3,072$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 6,302$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 386,295,030 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 1,158,885,090.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 7 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 386,295,030 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 1,545,180,120 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 1,552 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{1,545,180,120 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 7,648,641,594,000,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 1,545,180,120 T states, the 1,552 copies of the T factory are repeatedly invoked 995,606 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 1,525,084 are the product of the 6,302 logical qubits after layout and the 242 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 1,552 in parallel, therefore we need $5,028,480 = 3,240 \\cdot 1,552$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 6,302 logical qubits and the total cycle count 1,158,885,090."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 1,545,180,120."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000000616160338105412)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{11 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 6,600,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 242."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 2.91e-10."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 6,302 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2808648000,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 131072000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 131051076,
                        "runtime": 10661742828000,
                        "rqops": 685000000,
                        "breakdown": {
                            "algorithmicLogicalQubits": 6302,
                            "algorithmicLogicalDepth": 1158885090,
                            "logicalDepth": 1158885090,
                            "numTstates": 1545180120,
                            "clockFrequency": 108695.65217391304,
                            "numTfactories": 3733,
                            "numTfactoryRuns": 413925,
                            "physicalQubitsForTfactories": 124383560,
                            "physicalQubitsForAlgorithm": 6667516,
                            "requiredLogicalQubitErrorRate": 6.16160338105412e-14,
                            "requiredLogicalTstateErrorRate": 2.9122818380552293e-10,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "3 hours",
                        "rqops": "685.00M",
                        "physicalQubits": "131.05M",
                        "algorithmicLogicalQubits": "6.30k",
                        "algorithmicLogicalDepth": "1.16G",
                        "logicalDepth": "1.16G",
                        "numTstates": "1.55G",
                        "numTfactories": "3.73k",
                        "numTfactoryRuns": "413.93k",
                        "physicalQubitsForAlgorithm": "6.67M",
                        "physicalQubitsForTfactories": "124.38M",
                        "physicalQubitsForTfactoriesPercentage": "94.91 %",
                        "requiredLogicalQubitErrorRate": "6.16e-14",
                        "requiredLogicalTstateErrorRate": "2.91e-10",
                        "physicalQubitsPerLogicalQubit": "1.06k",
                        "logicalCycleTime": "9 microsecs",
                        "clockFrequency": "108.70k",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "111 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 17",
                        "physicalQubitsPerRound": "33.32k, 17.92k",
                        "tfactoryRuntimePerRound": "36 microsecs, 75 microsecs",
                        "tstateLogicalErrorRate": "2.13e-10",
                        "logicalCountsNumQubits": "3.07k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "386.30M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "131072000"
                    },
                    "logicalQubit": {
                        "codeDistance": 23,
                        "physicalQubits": 1058,
                        "logicalCycleTime": 9200,
                        "logicalErrorRate": 3.000000000000004e-14
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 111200,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            17
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            17918
                        ],
                        "runtimePerRound": [
                            36400,
                            74800
                        ],
                        "logicalErrorRate": 2.133398959469633e-10
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 3072,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 386295030,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (9,200 nanosecs) multiplied by the 1,158,885,090 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 111,200 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (6,302) (with a logical error rate of 6.16e-14) multiplied by the clock frequency (108,695.65), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 6,667,516 physical qubits to implement the algorithm logic, and 124,383,560 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 3,072$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 6,302$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 386,295,030 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 1,158,885,090.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 9 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 386,295,030 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 1,545,180,120 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 3,733 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{1,545,180,120 \\cdot 111,200\\;\\text{ns}}{1 \\cdot 10,661,742,828,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 1,545,180,120 T states, the 3,733 copies of the T factory are repeatedly invoked 413,925 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 6,667,516 are the product of the 6,302 logical qubits after layout and the 1,058 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 3,733 in parallel, therefore we need $124,383,560 = 33,320 \\cdot 3,733$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 6,302 logical qubits and the total cycle count 1,158,885,090."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 1,545,180,120."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000000616160338105412)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{23 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 9,200 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,058."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.13e-10."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 2.91e-10."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 6,302 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2808648000,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 13107200,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 13104844,
                        "runtime": 7648641594000000,
                        "rqops": 954849,
                        "breakdown": {
                            "algorithmicLogicalQubits": 6302,
                            "algorithmicLogicalDepth": 1158885090,
                            "logicalDepth": 1158885090,
                            "numTstates": 1545180120,
                            "clockFrequency": 151.5151515151515,
                            "numTfactories": 3574,
                            "numTfactoryRuns": 432340,
                            "physicalQubitsForTfactories": 11579760,
                            "physicalQubitsForAlgorithm": 1525084,
                            "requiredLogicalQubitErrorRate": 6.16160338105412e-14,
                            "requiredLogicalTstateErrorRate": 2.9122818380552293e-10,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "89 days",
                        "rqops": "954.85k",
                        "physicalQubits": "13.10M",
                        "algorithmicLogicalQubits": "6.30k",
                        "algorithmicLogicalDepth": "1.16G",
                        "logicalDepth": "1.16G",
                        "numTstates": "1.55G",
                        "numTfactories": "3.57k",
                        "numTfactoryRuns": "432.34k",
                        "physicalQubitsForAlgorithm": "1.53M",
                        "physicalQubitsForTfactories": "11.58M",
                        "physicalQubitsForTfactoriesPercentage": "88.36 %",
                        "requiredLogicalQubitErrorRate": "6.16e-14",
                        "requiredLogicalTstateErrorRate": "2.91e-10",
                        "physicalQubitsPerLogicalQubit": "242",
                        "logicalCycleTime": "7 millisecs",
                        "clockFrequency": "152",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "3.07k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "386.30M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "13107200"
                    },
                    "logicalQubit": {
                        "codeDistance": 11,
                        "physicalQubits": 242,
                        "logicalCycleTime": 6600000,
                        "logicalErrorRate": 3e-14
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 3072,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 386295030,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (6,600,000 nanosecs) multiplied by the 1,158,885,090 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (6,302) (with a logical error rate of 6.16e-14) multiplied by the clock frequency (151.52), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 1,525,084 physical qubits to implement the algorithm logic, and 11,579,760 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 3,072$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 6,302$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 386,295,030 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 1,158,885,090.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 7 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 386,295,030 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 1,545,180,120 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 3,574 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{1,545,180,120 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 7,648,641,594,000,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 1,545,180,120 T states, the 3,574 copies of the T factory are repeatedly invoked 432,340 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 1,525,084 are the product of the 6,302 logical qubits after layout and the 242 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 3,574 in parallel, therefore we need $11,579,760 = 3,240 \\cdot 3,574$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 6,302 logical qubits and the total cycle count 1,158,885,090."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 1,545,180,120."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000000616160338105412)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{11 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 6,600,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 242."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 2.91e-10."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 6,302 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2871763200,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 262144000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 262131956,
                        "runtime": 10661742828000,
                        "rqops": 685000000,
                        "breakdown": {
                            "algorithmicLogicalQubits": 6302,
                            "algorithmicLogicalDepth": 1158885090,
                            "logicalDepth": 1158885090,
                            "numTstates": 1545180120,
                            "clockFrequency": 108695.65217391304,
                            "numTfactories": 7667,
                            "numTfactoryRuns": 201537,
                            "physicalQubitsForTfactories": 255464440,
                            "physicalQubitsForAlgorithm": 6667516,
                            "requiredLogicalQubitErrorRate": 6.16160338105412e-14,
                            "requiredLogicalTstateErrorRate": 2.9122818380552293e-10,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "3 hours",
                        "rqops": "685.00M",
                        "physicalQubits": "262.13M",
                        "algorithmicLogicalQubits": "6.30k",
                        "algorithmicLogicalDepth": "1.16G",
                        "logicalDepth": "1.16G",
                        "numTstates": "1.55G",
                        "numTfactories": "7.67k",
                        "numTfactoryRuns": "201.54k",
                        "physicalQubitsForAlgorithm": "6.67M",
                        "physicalQubitsForTfactories": "255.46M",
                        "physicalQubitsForTfactoriesPercentage": "97.46 %",
                        "requiredLogicalQubitErrorRate": "6.16e-14",
                        "requiredLogicalTstateErrorRate": "2.91e-10",
                        "physicalQubitsPerLogicalQubit": "1.06k",
                        "logicalCycleTime": "9 microsecs",
                        "clockFrequency": "108.70k",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "111 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 17",
                        "physicalQubitsPerRound": "33.32k, 17.92k",
                        "tfactoryRuntimePerRound": "36 microsecs, 75 microsecs",
                        "tstateLogicalErrorRate": "2.13e-10",
                        "logicalCountsNumQubits": "3.07k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "386.30M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "262144000"
                    },
                    "logicalQubit": {
                        "codeDistance": 23,
                        "physicalQubits": 1058,
                        "logicalCycleTime": 9200,
                        "logicalErrorRate": 3.000000000000004e-14
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 111200,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            17
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            17918
                        ],
                        "runtimePerRound": [
                            36400,
                            74800
                        ],
                        "logicalErrorRate": 2.133398959469633e-10
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 3072,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 386295030,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (9,200 nanosecs) multiplied by the 1,158,885,090 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 111,200 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (6,302) (with a logical error rate of 6.16e-14) multiplied by the clock frequency (108,695.65), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 6,667,516 physical qubits to implement the algorithm logic, and 255,464,440 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 3,072$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 6,302$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 386,295,030 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 1,158,885,090.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 9 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 386,295,030 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 1,545,180,120 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 7,667 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{1,545,180,120 \\cdot 111,200\\;\\text{ns}}{1 \\cdot 10,661,742,828,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 1,545,180,120 T states, the 7,667 copies of the T factory are repeatedly invoked 201,537 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 6,667,516 are the product of the 6,302 logical qubits after layout and the 1,058 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 7,667 in parallel, therefore we need $255,464,440 = 33,320 \\cdot 7,667$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 6,302 logical qubits and the total cycle count 1,158,885,090."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 1,545,180,120."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000000616160338105412)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{23 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 9,200 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,058."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.13e-10."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 2.91e-10."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 6,302 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2871763200,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 26214400,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 26213884,
                        "runtime": 7648641594000000,
                        "rqops": 954849,
                        "breakdown": {
                            "algorithmicLogicalQubits": 6302,
                            "algorithmicLogicalDepth": 1158885090,
                            "logicalDepth": 1158885090,
                            "numTstates": 1545180120,
                            "clockFrequency": 151.5151515151515,
                            "numTfactories": 7620,
                            "numTfactoryRuns": 202780,
                            "physicalQubitsForTfactories": 24688800,
                            "physicalQubitsForAlgorithm": 1525084,
                            "requiredLogicalQubitErrorRate": 6.16160338105412e-14,
                            "requiredLogicalTstateErrorRate": 2.9122818380552293e-10,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "89 days",
                        "rqops": "954.85k",
                        "physicalQubits": "26.21M",
                        "algorithmicLogicalQubits": "6.30k",
                        "algorithmicLogicalDepth": "1.16G",
                        "logicalDepth": "1.16G",
                        "numTstates": "1.55G",
                        "numTfactories": "7.62k",
                        "numTfactoryRuns": "202.78k",
                        "physicalQubitsForAlgorithm": "1.53M",
                        "physicalQubitsForTfactories": "24.69M",
                        "physicalQubitsForTfactoriesPercentage": "94.18 %",
                        "requiredLogicalQubitErrorRate": "6.16e-14",
                        "requiredLogicalTstateErrorRate": "2.91e-10",
                        "physicalQubitsPerLogicalQubit": "242",
                        "logicalCycleTime": "7 millisecs",
                        "clockFrequency": "152",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "3.07k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "386.30M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "26214400"
                    },
                    "logicalQubit": {
                        "codeDistance": 11,
                        "physicalQubits": 242,
                        "logicalCycleTime": 6600000,
                        "logicalErrorRate": 3e-14
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 3072,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 386295030,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (6,600,000 nanosecs) multiplied by the 1,158,885,090 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (6,302) (with a logical error rate of 6.16e-14) multiplied by the clock frequency (151.52), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 1,525,084 physical qubits to implement the algorithm logic, and 24,688,800 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 3,072$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 6,302$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 386,295,030 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 1,158,885,090.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 7 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 386,295,030 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 1,545,180,120 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 7,620 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{1,545,180,120 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 7,648,641,594,000,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 1,545,180,120 T states, the 7,620 copies of the T factory are repeatedly invoked 202,780 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 1,525,084 are the product of the 6,302 logical qubits after layout and the 242 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 7,620 in parallel, therefore we need $24,688,800 = 3,240 \\cdot 7,620$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 6,302 logical qubits and the total cycle count 1,158,885,090."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 1,545,180,120."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000000616160338105412)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{11 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 6,600,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 242."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 2.91e-10."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 6,302 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2934878400,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 524288000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 524260396,
                        "runtime": 10661742828000,
                        "rqops": 685000000,
                        "breakdown": {
                            "algorithmicLogicalQubits": 6302,
                            "algorithmicLogicalDepth": 1158885090,
                            "logicalDepth": 1158885090,
                            "numTstates": 1545180120,
                            "clockFrequency": 108695.65217391304,
                            "numTfactories": 15534,
                            "numTfactoryRuns": 99471,
                            "physicalQubitsForTfactories": 517592880,
                            "physicalQubitsForAlgorithm": 6667516,
                            "requiredLogicalQubitErrorRate": 6.16160338105412e-14,
                            "requiredLogicalTstateErrorRate": 2.9122818380552293e-10,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "3 hours",
                        "rqops": "685.00M",
                        "physicalQubits": "524.26M",
                        "algorithmicLogicalQubits": "6.30k",
                        "algorithmicLogicalDepth": "1.16G",
                        "logicalDepth": "1.16G",
                        "numTstates": "1.55G",
                        "numTfactories": "15.53k",
                        "numTfactoryRuns": "99.47k",
                        "physicalQubitsForAlgorithm": "6.67M",
                        "physicalQubitsForTfactories": "517.59M",
                        "physicalQubitsForTfactoriesPercentage": "98.73 %",
                        "requiredLogicalQubitErrorRate": "6.16e-14",
                        "requiredLogicalTstateErrorRate": "2.91e-10",
                        "physicalQubitsPerLogicalQubit": "1.06k",
                        "logicalCycleTime": "9 microsecs",
                        "clockFrequency": "108.70k",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "111 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 17",
                        "physicalQubitsPerRound": "33.32k, 17.92k",
                        "tfactoryRuntimePerRound": "36 microsecs, 75 microsecs",
                        "tstateLogicalErrorRate": "2.13e-10",
                        "logicalCountsNumQubits": "3.07k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "386.30M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "524288000"
                    },
                    "logicalQubit": {
                        "codeDistance": 23,
                        "physicalQubits": 1058,
                        "logicalCycleTime": 9200,
                        "logicalErrorRate": 3.000000000000004e-14
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 111200,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            17
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            17918
                        ],
                        "runtimePerRound": [
                            36400,
                            74800
                        ],
                        "logicalErrorRate": 2.133398959469633e-10
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 3072,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 386295030,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (9,200 nanosecs) multiplied by the 1,158,885,090 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 111,200 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (6,302) (with a logical error rate of 6.16e-14) multiplied by the clock frequency (108,695.65), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 6,667,516 physical qubits to implement the algorithm logic, and 517,592,880 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 3,072$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 6,302$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 386,295,030 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 1,158,885,090.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 9 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 386,295,030 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 1,545,180,120 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 15,534 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{1,545,180,120 \\cdot 111,200\\;\\text{ns}}{1 \\cdot 10,661,742,828,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 1,545,180,120 T states, the 15,534 copies of the T factory are repeatedly invoked 99,471 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 6,667,516 are the product of the 6,302 logical qubits after layout and the 1,058 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 15,534 in parallel, therefore we need $517,592,880 = 33,320 \\cdot 15,534$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 6,302 logical qubits and the total cycle count 1,158,885,090."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 1,545,180,120."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000000616160338105412)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{23 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 9,200 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,058."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.13e-10."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 2.91e-10."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 6,302 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2934878400,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 52428800,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 52428724,
                        "runtime": 7648641594000000,
                        "rqops": 954849,
                        "breakdown": {
                            "algorithmicLogicalQubits": 6302,
                            "algorithmicLogicalDepth": 1158885090,
                            "logicalDepth": 1158885090,
                            "numTstates": 1545180120,
                            "clockFrequency": 151.5151515151515,
                            "numTfactories": 15711,
                            "numTfactoryRuns": 98351,
                            "physicalQubitsForTfactories": 50903640,
                            "physicalQubitsForAlgorithm": 1525084,
                            "requiredLogicalQubitErrorRate": 6.16160338105412e-14,
                            "requiredLogicalTstateErrorRate": 2.9122818380552293e-10,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "89 days",
                        "rqops": "954.85k",
                        "physicalQubits": "52.43M",
                        "algorithmicLogicalQubits": "6.30k",
                        "algorithmicLogicalDepth": "1.16G",
                        "logicalDepth": "1.16G",
                        "numTstates": "1.55G",
                        "numTfactories": "15.71k",
                        "numTfactoryRuns": "98.35k",
                        "physicalQubitsForAlgorithm": "1.53M",
                        "physicalQubitsForTfactories": "50.90M",
                        "physicalQubitsForTfactoriesPercentage": "97.09 %",
                        "requiredLogicalQubitErrorRate": "6.16e-14",
                        "requiredLogicalTstateErrorRate": "2.91e-10",
                        "physicalQubitsPerLogicalQubit": "242",
                        "logicalCycleTime": "7 millisecs",
                        "clockFrequency": "152",
                        "logicalErrorRate": "3.00e-14",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "3.07k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "386.30M",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "52428800"
                    },
                    "logicalQubit": {
                        "codeDistance": 11,
                        "physicalQubits": 242,
                        "logicalCycleTime": 6600000,
                        "logicalErrorRate": 3e-14
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 3072,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 386295030,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (6,600,000 nanosecs) multiplied by the 1,158,885,090 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (6,302) (with a logical error rate of 6.16e-14) multiplied by the clock frequency (151.52), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 1,525,084 physical qubits to implement the algorithm logic, and 50,903,640 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 3,072$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 6,302$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 386,295,030 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 1,158,885,090.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 7 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 386,295,030 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 1,545,180,120 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 15,711 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{1,545,180,120 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 7,648,641,594,000,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 1,545,180,120 T states, the 15,711 copies of the T factory are repeatedly invoked 98,351 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 1,525,084 are the product of the 6,302 logical qubits after layout and the 242 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 15,711 in parallel, therefore we need $50,903,640 = 3,240 \\cdot 15,711$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 6,302 logical qubits and the total cycle count 1,158,885,090."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 1,545,180,120."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000000616160338105412)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{11 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 6,600,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 242."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 2.91e-10."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 6,302 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            }
        ]
    },
    {
        "protocol": "RSA-2048",
        "threats": [
            {
                "timestamp": 2619302400,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 16384000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 16371790,
                        "runtime": 77279138640000,
                        "rqops": 1251100000,
                        "breakdown": {
                            "algorithmicLogicalQubits": 12511,
                            "algorithmicLogicalDepth": 7727913864,
                            "logicalDepth": 7727913864,
                            "numTstates": 10303885152,
                            "clockFrequency": 100000.0,
                            "numTfactories": 22,
                            "numTfactoryRuns": 468358416,
                            "physicalQubitsForTfactories": 733040,
                            "physicalQubitsForAlgorithm": 15638750,
                            "requiredLogicalQubitErrorRate": 4.654341195680876e-15,
                            "requiredLogicalTstateErrorRate": 4.367284702437258e-11,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "21 hours",
                        "rqops": "1.25G",
                        "physicalQubits": "16.37M",
                        "algorithmicLogicalQubits": "12.51k",
                        "algorithmicLogicalDepth": "7.73G",
                        "logicalDepth": "7.73G",
                        "numTstates": "10.30G",
                        "numTfactories": "22",
                        "numTfactoryRuns": "468.36M",
                        "physicalQubitsForAlgorithm": "15.64M",
                        "physicalQubitsForTfactories": "733.04k",
                        "physicalQubitsForTfactoriesPercentage": "4.48 %",
                        "requiredLogicalQubitErrorRate": "4.65e-15",
                        "requiredLogicalTstateErrorRate": "4.37e-11",
                        "physicalQubitsPerLogicalQubit": "1.25k",
                        "logicalCycleTime": "10 microsecs",
                        "clockFrequency": "100.00k",
                        "logicalErrorRate": "3.00e-15",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "120 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 19",
                        "physicalQubitsPerRound": "33.32k, 22.38k",
                        "tfactoryRuntimePerRound": "36 microsecs, 84 microsecs",
                        "tstateLogicalErrorRate": "2.16e-11",
                        "logicalCountsNumQubits": "6.14k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "2.58G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "16384000"
                    },
                    "logicalQubit": {
                        "codeDistance": 25,
                        "physicalQubits": 1250,
                        "logicalCycleTime": 10000,
                        "logicalErrorRate": 3.000000000000004e-15
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 120000,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            19
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            22382
                        ],
                        "runtimePerRound": [
                            36400,
                            83600
                        ],
                        "logicalErrorRate": 2.1639895946963144e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 6144,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 2575971288,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (10,000 nanosecs) multiplied by the 7,727,913,864 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 120,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (12,511) (with a logical error rate of 4.65e-15) multiplied by the clock frequency (100,000.00), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 15,638,750 physical qubits to implement the algorithm logic, and 733,040 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 6,144$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 12,511$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 2,575,971,288 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 7,727,913,864.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 10 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 2,575,971,288 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 10,303,885,152 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 22 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{10,303,885,152 \\cdot 120,000\\;\\text{ns}}{1 \\cdot 77,279,138,640,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 10,303,885,152 T states, the 22 copies of the T factory are repeatedly invoked 468,358,416 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 15,638,750 are the product of the 12,511 logical qubits after layout and the 1,250 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 22 in parallel, therefore we need $733,040 = 33,320 \\cdot 22$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 12,511 logical qubits and the total cycle count 7,727,913,864."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 10,303,885,152."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.000000000000004654341195680876)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{25 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 10,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,250."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.16e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 4.37e-11."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 12,511 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2682417600,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 32768000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 32765230,
                        "runtime": 77279138640000,
                        "rqops": 1251100000,
                        "breakdown": {
                            "algorithmicLogicalQubits": 12511,
                            "algorithmicLogicalDepth": 7727913864,
                            "logicalDepth": 7727913864,
                            "numTstates": 10303885152,
                            "clockFrequency": 100000.0,
                            "numTfactories": 514,
                            "numTfactoryRuns": 20046470,
                            "physicalQubitsForTfactories": 17126480,
                            "physicalQubitsForAlgorithm": 15638750,
                            "requiredLogicalQubitErrorRate": 4.654341195680876e-15,
                            "requiredLogicalTstateErrorRate": 4.367284702437258e-11,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "21 hours",
                        "rqops": "1.25G",
                        "physicalQubits": "32.77M",
                        "algorithmicLogicalQubits": "12.51k",
                        "algorithmicLogicalDepth": "7.73G",
                        "logicalDepth": "7.73G",
                        "numTstates": "10.30G",
                        "numTfactories": "514",
                        "numTfactoryRuns": "20.05M",
                        "physicalQubitsForAlgorithm": "15.64M",
                        "physicalQubitsForTfactories": "17.13M",
                        "physicalQubitsForTfactoriesPercentage": "52.27 %",
                        "requiredLogicalQubitErrorRate": "4.65e-15",
                        "requiredLogicalTstateErrorRate": "4.37e-11",
                        "physicalQubitsPerLogicalQubit": "1.25k",
                        "logicalCycleTime": "10 microsecs",
                        "clockFrequency": "100.00k",
                        "logicalErrorRate": "3.00e-15",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "120 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 19",
                        "physicalQubitsPerRound": "33.32k, 22.38k",
                        "tfactoryRuntimePerRound": "36 microsecs, 84 microsecs",
                        "tstateLogicalErrorRate": "2.16e-11",
                        "logicalCountsNumQubits": "6.14k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "2.58G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "32768000"
                    },
                    "logicalQubit": {
                        "codeDistance": 25,
                        "physicalQubits": 1250,
                        "logicalCycleTime": 10000,
                        "logicalErrorRate": 3.000000000000004e-15
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 120000,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            19
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            22382
                        ],
                        "runtimePerRound": [
                            36400,
                            83600
                        ],
                        "logicalErrorRate": 2.1639895946963144e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 6144,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 2575971288,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (10,000 nanosecs) multiplied by the 7,727,913,864 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 120,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (12,511) (with a logical error rate of 4.65e-15) multiplied by the clock frequency (100,000.00), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 15,638,750 physical qubits to implement the algorithm logic, and 17,126,480 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 6,144$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 12,511$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 2,575,971,288 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 7,727,913,864.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 10 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 2,575,971,288 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 10,303,885,152 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 514 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{10,303,885,152 \\cdot 120,000\\;\\text{ns}}{1 \\cdot 77,279,138,640,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 10,303,885,152 T states, the 514 copies of the T factory are repeatedly invoked 20,046,470 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 15,638,750 are the product of the 12,511 logical qubits after layout and the 1,250 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 514 in parallel, therefore we need $17,126,480 = 33,320 \\cdot 514$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 12,511 logical qubits and the total cycle count 7,727,913,864."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 10,303,885,152."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.000000000000004654341195680876)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{25 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 10,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,250."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.16e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 4.37e-11."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 12,511 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2745532800,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 65536000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 65518790,
                        "runtime": 77279138640000,
                        "rqops": 1251100000,
                        "breakdown": {
                            "algorithmicLogicalQubits": 12511,
                            "algorithmicLogicalDepth": 7727913864,
                            "logicalDepth": 7727913864,
                            "numTstates": 10303885152,
                            "clockFrequency": 100000.0,
                            "numTfactories": 1497,
                            "numTfactoryRuns": 6883023,
                            "physicalQubitsForTfactories": 49880040,
                            "physicalQubitsForAlgorithm": 15638750,
                            "requiredLogicalQubitErrorRate": 4.654341195680876e-15,
                            "requiredLogicalTstateErrorRate": 4.367284702437258e-11,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "21 hours",
                        "rqops": "1.25G",
                        "physicalQubits": "65.52M",
                        "algorithmicLogicalQubits": "12.51k",
                        "algorithmicLogicalDepth": "7.73G",
                        "logicalDepth": "7.73G",
                        "numTstates": "10.30G",
                        "numTfactories": "1.50k",
                        "numTfactoryRuns": "6.88M",
                        "physicalQubitsForAlgorithm": "15.64M",
                        "physicalQubitsForTfactories": "49.88M",
                        "physicalQubitsForTfactoriesPercentage": "76.13 %",
                        "requiredLogicalQubitErrorRate": "4.65e-15",
                        "requiredLogicalTstateErrorRate": "4.37e-11",
                        "physicalQubitsPerLogicalQubit": "1.25k",
                        "logicalCycleTime": "10 microsecs",
                        "clockFrequency": "100.00k",
                        "logicalErrorRate": "3.00e-15",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "120 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 19",
                        "physicalQubitsPerRound": "33.32k, 22.38k",
                        "tfactoryRuntimePerRound": "36 microsecs, 84 microsecs",
                        "tstateLogicalErrorRate": "2.16e-11",
                        "logicalCountsNumQubits": "6.14k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "2.58G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "65536000"
                    },
                    "logicalQubit": {
                        "codeDistance": 25,
                        "physicalQubits": 1250,
                        "logicalCycleTime": 10000,
                        "logicalErrorRate": 3.000000000000004e-15
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 120000,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            19
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            22382
                        ],
                        "runtimePerRound": [
                            36400,
                            83600
                        ],
                        "logicalErrorRate": 2.1639895946963144e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 6144,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 2575971288,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (10,000 nanosecs) multiplied by the 7,727,913,864 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 120,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (12,511) (with a logical error rate of 4.65e-15) multiplied by the clock frequency (100,000.00), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 15,638,750 physical qubits to implement the algorithm logic, and 49,880,040 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 6,144$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 12,511$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 2,575,971,288 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 7,727,913,864.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 10 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 2,575,971,288 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 10,303,885,152 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 1,497 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{10,303,885,152 \\cdot 120,000\\;\\text{ns}}{1 \\cdot 77,279,138,640,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 10,303,885,152 T states, the 1,497 copies of the T factory are repeatedly invoked 6,883,023 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 15,638,750 are the product of the 12,511 logical qubits after layout and the 1,250 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 1,497 in parallel, therefore we need $49,880,040 = 33,320 \\cdot 1,497$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 12,511 logical qubits and the total cycle count 7,727,913,864."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 10,303,885,152."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.000000000000004654341195680876)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{25 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 10,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,250."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.16e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 4.37e-11."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 12,511 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2745532800,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 6553600,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 6551798,
                        "runtime": 60277728139200000,
                        "rqops": 1603975,
                        "breakdown": {
                            "algorithmicLogicalQubits": 12511,
                            "algorithmicLogicalDepth": 7727913864,
                            "logicalDepth": 7727913864,
                            "numTstates": 10303885152,
                            "clockFrequency": 128.2051282051282,
                            "numTfactories": 717,
                            "numTfactoryRuns": 14370831,
                            "physicalQubitsForTfactories": 2323080,
                            "physicalQubitsForAlgorithm": 4228718,
                            "requiredLogicalQubitErrorRate": 4.654341195680876e-15,
                            "requiredLogicalTstateErrorRate": 4.367284702437258e-11,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "1 years",
                        "rqops": "1.60M",
                        "physicalQubits": "6.55M",
                        "algorithmicLogicalQubits": "12.51k",
                        "algorithmicLogicalDepth": "7.73G",
                        "logicalDepth": "7.73G",
                        "numTstates": "10.30G",
                        "numTfactories": "717",
                        "numTfactoryRuns": "14.37M",
                        "physicalQubitsForAlgorithm": "4.23M",
                        "physicalQubitsForTfactories": "2.32M",
                        "physicalQubitsForTfactoriesPercentage": "35.46 %",
                        "requiredLogicalQubitErrorRate": "4.65e-15",
                        "requiredLogicalTstateErrorRate": "4.37e-11",
                        "physicalQubitsPerLogicalQubit": "338",
                        "logicalCycleTime": "8 millisecs",
                        "clockFrequency": "128",
                        "logicalErrorRate": "3.00e-16",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "6.14k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "2.58G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "6553600"
                    },
                    "logicalQubit": {
                        "codeDistance": 13,
                        "physicalQubits": 338,
                        "logicalCycleTime": 7800000,
                        "logicalErrorRate": 3.0000000000000004e-16
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 6144,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 2575971288,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (7,800,000 nanosecs) multiplied by the 7,727,913,864 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (12,511) (with a logical error rate of 4.65e-15) multiplied by the clock frequency (128.21), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 4,228,718 physical qubits to implement the algorithm logic, and 2,323,080 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 6,144$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 12,511$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 2,575,971,288 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 7,727,913,864.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 8 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 2,575,971,288 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 10,303,885,152 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 717 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{10,303,885,152 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 60,277,728,139,200,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 10,303,885,152 T states, the 717 copies of the T factory are repeatedly invoked 14,370,831 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 4,228,718 are the product of the 12,511 logical qubits after layout and the 338 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 717 in parallel, therefore we need $2,323,080 = 3,240 \\cdot 717$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 12,511 logical qubits and the total cycle count 7,727,913,864."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 10,303,885,152."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.000000000000004654341195680876)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{13 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 7,800,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 338."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 4.37e-11."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 12,511 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2808648000,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 131072000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 131059230,
                        "runtime": 77279138640000,
                        "rqops": 1251100000,
                        "breakdown": {
                            "algorithmicLogicalQubits": 12511,
                            "algorithmicLogicalDepth": 7727913864,
                            "logicalDepth": 7727913864,
                            "numTstates": 10303885152,
                            "clockFrequency": 100000.0,
                            "numTfactories": 3464,
                            "numTfactoryRuns": 2974563,
                            "physicalQubitsForTfactories": 115420480,
                            "physicalQubitsForAlgorithm": 15638750,
                            "requiredLogicalQubitErrorRate": 4.654341195680876e-15,
                            "requiredLogicalTstateErrorRate": 4.367284702437258e-11,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "21 hours",
                        "rqops": "1.25G",
                        "physicalQubits": "131.06M",
                        "algorithmicLogicalQubits": "12.51k",
                        "algorithmicLogicalDepth": "7.73G",
                        "logicalDepth": "7.73G",
                        "numTstates": "10.30G",
                        "numTfactories": "3.46k",
                        "numTfactoryRuns": "2.97M",
                        "physicalQubitsForAlgorithm": "15.64M",
                        "physicalQubitsForTfactories": "115.42M",
                        "physicalQubitsForTfactoriesPercentage": "88.07 %",
                        "requiredLogicalQubitErrorRate": "4.65e-15",
                        "requiredLogicalTstateErrorRate": "4.37e-11",
                        "physicalQubitsPerLogicalQubit": "1.25k",
                        "logicalCycleTime": "10 microsecs",
                        "clockFrequency": "100.00k",
                        "logicalErrorRate": "3.00e-15",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "120 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 19",
                        "physicalQubitsPerRound": "33.32k, 22.38k",
                        "tfactoryRuntimePerRound": "36 microsecs, 84 microsecs",
                        "tstateLogicalErrorRate": "2.16e-11",
                        "logicalCountsNumQubits": "6.14k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "2.58G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "131072000"
                    },
                    "logicalQubit": {
                        "codeDistance": 25,
                        "physicalQubits": 1250,
                        "logicalCycleTime": 10000,
                        "logicalErrorRate": 3.000000000000004e-15
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 120000,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            19
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            22382
                        ],
                        "runtimePerRound": [
                            36400,
                            83600
                        ],
                        "logicalErrorRate": 2.1639895946963144e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 6144,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 2575971288,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (10,000 nanosecs) multiplied by the 7,727,913,864 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 120,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (12,511) (with a logical error rate of 4.65e-15) multiplied by the clock frequency (100,000.00), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 15,638,750 physical qubits to implement the algorithm logic, and 115,420,480 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 6,144$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 12,511$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 2,575,971,288 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 7,727,913,864.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 10 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 2,575,971,288 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 10,303,885,152 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 3,464 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{10,303,885,152 \\cdot 120,000\\;\\text{ns}}{1 \\cdot 77,279,138,640,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 10,303,885,152 T states, the 3,464 copies of the T factory are repeatedly invoked 2,974,563 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 15,638,750 are the product of the 12,511 logical qubits after layout and the 1,250 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 3,464 in parallel, therefore we need $115,420,480 = 33,320 \\cdot 3,464$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 12,511 logical qubits and the total cycle count 7,727,913,864."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 10,303,885,152."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.000000000000004654341195680876)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{25 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 10,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,250."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.16e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 4.37e-11."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 12,511 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2808648000,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 13107200,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 13106318,
                        "runtime": 60277728139200000,
                        "rqops": 1603975,
                        "breakdown": {
                            "algorithmicLogicalQubits": 12511,
                            "algorithmicLogicalDepth": 7727913864,
                            "logicalDepth": 7727913864,
                            "numTstates": 10303885152,
                            "clockFrequency": 128.2051282051282,
                            "numTfactories": 2740,
                            "numTfactoryRuns": 3760543,
                            "physicalQubitsForTfactories": 8877600,
                            "physicalQubitsForAlgorithm": 4228718,
                            "requiredLogicalQubitErrorRate": 4.654341195680876e-15,
                            "requiredLogicalTstateErrorRate": 4.367284702437258e-11,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "1 years",
                        "rqops": "1.60M",
                        "physicalQubits": "13.11M",
                        "algorithmicLogicalQubits": "12.51k",
                        "algorithmicLogicalDepth": "7.73G",
                        "logicalDepth": "7.73G",
                        "numTstates": "10.30G",
                        "numTfactories": "2.74k",
                        "numTfactoryRuns": "3.76M",
                        "physicalQubitsForAlgorithm": "4.23M",
                        "physicalQubitsForTfactories": "8.88M",
                        "physicalQubitsForTfactoriesPercentage": "67.74 %",
                        "requiredLogicalQubitErrorRate": "4.65e-15",
                        "requiredLogicalTstateErrorRate": "4.37e-11",
                        "physicalQubitsPerLogicalQubit": "338",
                        "logicalCycleTime": "8 millisecs",
                        "clockFrequency": "128",
                        "logicalErrorRate": "3.00e-16",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "6.14k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "2.58G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "13107200"
                    },
                    "logicalQubit": {
                        "codeDistance": 13,
                        "physicalQubits": 338,
                        "logicalCycleTime": 7800000,
                        "logicalErrorRate": 3.0000000000000004e-16
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 6144,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 2575971288,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (7,800,000 nanosecs) multiplied by the 7,727,913,864 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (12,511) (with a logical error rate of 4.65e-15) multiplied by the clock frequency (128.21), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 4,228,718 physical qubits to implement the algorithm logic, and 8,877,600 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 6,144$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 12,511$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 2,575,971,288 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 7,727,913,864.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 8 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 2,575,971,288 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 10,303,885,152 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 2,740 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{10,303,885,152 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 60,277,728,139,200,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 10,303,885,152 T states, the 2,740 copies of the T factory are repeatedly invoked 3,760,543 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 4,228,718 are the product of the 12,511 logical qubits after layout and the 338 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 2,740 in parallel, therefore we need $8,877,600 = 3,240 \\cdot 2,740$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 12,511 logical qubits and the total cycle count 7,727,913,864."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 10,303,885,152."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.000000000000004654341195680876)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{13 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 7,800,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 338."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 4.37e-11."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 12,511 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2871763200,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 262144000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 262140110,
                        "runtime": 77279138640000,
                        "rqops": 1251100000,
                        "breakdown": {
                            "algorithmicLogicalQubits": 12511,
                            "algorithmicLogicalDepth": 7727913864,
                            "logicalDepth": 7727913864,
                            "numTstates": 10303885152,
                            "clockFrequency": 100000.0,
                            "numTfactories": 7398,
                            "numTfactoryRuns": 1392794,
                            "physicalQubitsForTfactories": 246501360,
                            "physicalQubitsForAlgorithm": 15638750,
                            "requiredLogicalQubitErrorRate": 4.654341195680876e-15,
                            "requiredLogicalTstateErrorRate": 4.367284702437258e-11,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "21 hours",
                        "rqops": "1.25G",
                        "physicalQubits": "262.14M",
                        "algorithmicLogicalQubits": "12.51k",
                        "algorithmicLogicalDepth": "7.73G",
                        "logicalDepth": "7.73G",
                        "numTstates": "10.30G",
                        "numTfactories": "7.40k",
                        "numTfactoryRuns": "1.39M",
                        "physicalQubitsForAlgorithm": "15.64M",
                        "physicalQubitsForTfactories": "246.50M",
                        "physicalQubitsForTfactoriesPercentage": "94.03 %",
                        "requiredLogicalQubitErrorRate": "4.65e-15",
                        "requiredLogicalTstateErrorRate": "4.37e-11",
                        "physicalQubitsPerLogicalQubit": "1.25k",
                        "logicalCycleTime": "10 microsecs",
                        "clockFrequency": "100.00k",
                        "logicalErrorRate": "3.00e-15",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "120 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 19",
                        "physicalQubitsPerRound": "33.32k, 22.38k",
                        "tfactoryRuntimePerRound": "36 microsecs, 84 microsecs",
                        "tstateLogicalErrorRate": "2.16e-11",
                        "logicalCountsNumQubits": "6.14k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "2.58G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "262144000"
                    },
                    "logicalQubit": {
                        "codeDistance": 25,
                        "physicalQubits": 1250,
                        "logicalCycleTime": 10000,
                        "logicalErrorRate": 3.000000000000004e-15
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 120000,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            19
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            22382
                        ],
                        "runtimePerRound": [
                            36400,
                            83600
                        ],
                        "logicalErrorRate": 2.1639895946963144e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 6144,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 2575971288,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (10,000 nanosecs) multiplied by the 7,727,913,864 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 120,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (12,511) (with a logical error rate of 4.65e-15) multiplied by the clock frequency (100,000.00), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 15,638,750 physical qubits to implement the algorithm logic, and 246,501,360 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 6,144$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 12,511$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 2,575,971,288 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 7,727,913,864.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 10 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 2,575,971,288 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 10,303,885,152 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 7,398 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{10,303,885,152 \\cdot 120,000\\;\\text{ns}}{1 \\cdot 77,279,138,640,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 10,303,885,152 T states, the 7,398 copies of the T factory are repeatedly invoked 1,392,794 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 15,638,750 are the product of the 12,511 logical qubits after layout and the 1,250 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 7,398 in parallel, therefore we need $246,501,360 = 33,320 \\cdot 7,398$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 12,511 logical qubits and the total cycle count 7,727,913,864."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 10,303,885,152."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.000000000000004654341195680876)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{25 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 10,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,250."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.16e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 4.37e-11."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 12,511 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2871763200,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 26214400,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 26212118,
                        "runtime": 60277728139200000,
                        "rqops": 1603975,
                        "breakdown": {
                            "algorithmicLogicalQubits": 12511,
                            "algorithmicLogicalDepth": 7727913864,
                            "logicalDepth": 7727913864,
                            "numTstates": 10303885152,
                            "clockFrequency": 128.2051282051282,
                            "numTfactories": 6785,
                            "numTfactoryRuns": 1518628,
                            "physicalQubitsForTfactories": 21983400,
                            "physicalQubitsForAlgorithm": 4228718,
                            "requiredLogicalQubitErrorRate": 4.654341195680876e-15,
                            "requiredLogicalTstateErrorRate": 4.367284702437258e-11,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "1 years",
                        "rqops": "1.60M",
                        "physicalQubits": "26.21M",
                        "algorithmicLogicalQubits": "12.51k",
                        "algorithmicLogicalDepth": "7.73G",
                        "logicalDepth": "7.73G",
                        "numTstates": "10.30G",
                        "numTfactories": "6.79k",
                        "numTfactoryRuns": "1.52M",
                        "physicalQubitsForAlgorithm": "4.23M",
                        "physicalQubitsForTfactories": "21.98M",
                        "physicalQubitsForTfactoriesPercentage": "83.87 %",
                        "requiredLogicalQubitErrorRate": "4.65e-15",
                        "requiredLogicalTstateErrorRate": "4.37e-11",
                        "physicalQubitsPerLogicalQubit": "338",
                        "logicalCycleTime": "8 millisecs",
                        "clockFrequency": "128",
                        "logicalErrorRate": "3.00e-16",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "6.14k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "2.58G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "26214400"
                    },
                    "logicalQubit": {
                        "codeDistance": 13,
                        "physicalQubits": 338,
                        "logicalCycleTime": 7800000,
                        "logicalErrorRate": 3.0000000000000004e-16
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 6144,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 2575971288,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (7,800,000 nanosecs) multiplied by the 7,727,913,864 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (12,511) (with a logical error rate of 4.65e-15) multiplied by the clock frequency (128.21), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 4,228,718 physical qubits to implement the algorithm logic, and 21,983,400 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 6,144$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 12,511$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 2,575,971,288 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 7,727,913,864.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 8 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 2,575,971,288 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 10,303,885,152 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 6,785 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{10,303,885,152 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 60,277,728,139,200,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 10,303,885,152 T states, the 6,785 copies of the T factory are repeatedly invoked 1,518,628 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 4,228,718 are the product of the 12,511 logical qubits after layout and the 338 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 6,785 in parallel, therefore we need $21,983,400 = 3,240 \\cdot 6,785$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 12,511 logical qubits and the total cycle count 7,727,913,864."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 10,303,885,152."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.000000000000004654341195680876)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{13 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 7,800,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 338."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 4.37e-11."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 12,511 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2934878400,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 524288000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 524268550,
                        "runtime": 77279138640000,
                        "rqops": 1251100000,
                        "breakdown": {
                            "algorithmicLogicalQubits": 12511,
                            "algorithmicLogicalDepth": 7727913864,
                            "logicalDepth": 7727913864,
                            "numTstates": 10303885152,
                            "clockFrequency": 100000.0,
                            "numTfactories": 15265,
                            "numTfactoryRuns": 675001,
                            "physicalQubitsForTfactories": 508629800,
                            "physicalQubitsForAlgorithm": 15638750,
                            "requiredLogicalQubitErrorRate": 4.654341195680876e-15,
                            "requiredLogicalTstateErrorRate": 4.367284702437258e-11,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "21 hours",
                        "rqops": "1.25G",
                        "physicalQubits": "524.27M",
                        "algorithmicLogicalQubits": "12.51k",
                        "algorithmicLogicalDepth": "7.73G",
                        "logicalDepth": "7.73G",
                        "numTstates": "10.30G",
                        "numTfactories": "15.27k",
                        "numTfactoryRuns": "675.00k",
                        "physicalQubitsForAlgorithm": "15.64M",
                        "physicalQubitsForTfactories": "508.63M",
                        "physicalQubitsForTfactoriesPercentage": "97.02 %",
                        "requiredLogicalQubitErrorRate": "4.65e-15",
                        "requiredLogicalTstateErrorRate": "4.37e-11",
                        "physicalQubitsPerLogicalQubit": "1.25k",
                        "logicalCycleTime": "10 microsecs",
                        "clockFrequency": "100.00k",
                        "logicalErrorRate": "3.00e-15",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "120 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 19",
                        "physicalQubitsPerRound": "33.32k, 22.38k",
                        "tfactoryRuntimePerRound": "36 microsecs, 84 microsecs",
                        "tstateLogicalErrorRate": "2.16e-11",
                        "logicalCountsNumQubits": "6.14k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "2.58G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "524288000"
                    },
                    "logicalQubit": {
                        "codeDistance": 25,
                        "physicalQubits": 1250,
                        "logicalCycleTime": 10000,
                        "logicalErrorRate": 3.000000000000004e-15
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 120000,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            19
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            22382
                        ],
                        "runtimePerRound": [
                            36400,
                            83600
                        ],
                        "logicalErrorRate": 2.1639895946963144e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 6144,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 2575971288,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (10,000 nanosecs) multiplied by the 7,727,913,864 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 120,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (12,511) (with a logical error rate of 4.65e-15) multiplied by the clock frequency (100,000.00), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 15,638,750 physical qubits to implement the algorithm logic, and 508,629,800 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 6,144$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 12,511$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 2,575,971,288 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 7,727,913,864.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 10 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 2,575,971,288 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 10,303,885,152 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 15,265 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{10,303,885,152 \\cdot 120,000\\;\\text{ns}}{1 \\cdot 77,279,138,640,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 10,303,885,152 T states, the 15,265 copies of the T factory are repeatedly invoked 675,001 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 15,638,750 are the product of the 12,511 logical qubits after layout and the 1,250 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 15,265 in parallel, therefore we need $508,629,800 = 33,320 \\cdot 15,265$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 12,511 logical qubits and the total cycle count 7,727,913,864."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 10,303,885,152."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.000000000000004654341195680876)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{25 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 10,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,250."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.16e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 4.37e-11."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 12,511 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2934878400,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 52428800,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 52426958,
                        "runtime": 60277728139200000,
                        "rqops": 1603975,
                        "breakdown": {
                            "algorithmicLogicalQubits": 12511,
                            "algorithmicLogicalDepth": 7727913864,
                            "logicalDepth": 7727913864,
                            "numTstates": 10303885152,
                            "clockFrequency": 128.2051282051282,
                            "numTfactories": 14876,
                            "numTfactoryRuns": 692652,
                            "physicalQubitsForTfactories": 48198240,
                            "physicalQubitsForAlgorithm": 4228718,
                            "requiredLogicalQubitErrorRate": 4.654341195680876e-15,
                            "requiredLogicalTstateErrorRate": 4.367284702437258e-11,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "1 years",
                        "rqops": "1.60M",
                        "physicalQubits": "52.43M",
                        "algorithmicLogicalQubits": "12.51k",
                        "algorithmicLogicalDepth": "7.73G",
                        "logicalDepth": "7.73G",
                        "numTstates": "10.30G",
                        "numTfactories": "14.88k",
                        "numTfactoryRuns": "692.65k",
                        "physicalQubitsForAlgorithm": "4.23M",
                        "physicalQubitsForTfactories": "48.20M",
                        "physicalQubitsForTfactoriesPercentage": "91.93 %",
                        "requiredLogicalQubitErrorRate": "4.65e-15",
                        "requiredLogicalTstateErrorRate": "4.37e-11",
                        "physicalQubitsPerLogicalQubit": "338",
                        "logicalCycleTime": "8 millisecs",
                        "clockFrequency": "128",
                        "logicalErrorRate": "3.00e-16",
                        "tfactoryPhysicalQubits": "3.24k",
                        "tfactoryRuntime": "70 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "9",
                        "physicalQubitsPerRound": "3.24k",
                        "tfactoryRuntimePerRound": "70 millisecs",
                        "tstateLogicalErrorRate": "2.13e-11",
                        "logicalCountsNumQubits": "6.14k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "2.58G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "52428800"
                    },
                    "logicalQubit": {
                        "codeDistance": 13,
                        "physicalQubits": 338,
                        "logicalCycleTime": 7800000,
                        "logicalErrorRate": 3.0000000000000004e-16
                    },
                    "tfactory": {
                        "physicalQubits": 3240,
                        "runtime": 70200000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            9
                        ],
                        "physicalQubitsPerRound": [
                            3240
                        ],
                        "runtimePerRound": [
                            70200000
                        ],
                        "logicalErrorRate": 2.1300035e-11
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 6144,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 2575971288,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (7,800,000 nanosecs) multiplied by the 7,727,913,864 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 70,200,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (12,511) (with a logical error rate of 4.65e-15) multiplied by the clock frequency (128.21), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 4,228,718 physical qubits to implement the algorithm logic, and 48,198,240 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 6,144$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 12,511$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 2,575,971,288 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 7,727,913,864.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 8 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 2,575,971,288 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 10,303,885,152 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 14,876 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{10,303,885,152 \\cdot 70,200,000\\;\\text{ns}}{1 \\cdot 60,277,728,139,200,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 10,303,885,152 T states, the 14,876 copies of the T factory are repeatedly invoked 692,652 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 4,228,718 are the product of the 12,511 logical qubits after layout and the 338 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 3,240 physical qubits and we run 14,876 in parallel, therefore we need $48,198,240 = 3,240 \\cdot 14,876$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 12,511 logical qubits and the total cycle count 7,727,913,864."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 10,303,885,152."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.000000000000004654341195680876)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{13 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 7,800,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 338."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-11."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 4.37e-11."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 12,511 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            }
        ]
    },
    {
        "protocol": "RSA-4096",
        "threats": [
            {
                "timestamp": 2745532800,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 65536000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 65512718,
                        "runtime": 601027248204000,
                        "rqops": 2304722223,
                        "breakdown": {
                            "algorithmicLogicalQubits": 24891,
                            "algorithmicLogicalDepth": 55650671130,
                            "logicalDepth": 55650671130,
                            "numTstates": 74200894840,
                            "clockFrequency": 92592.5925925926,
                            "numTfactories": 877,
                            "numTfactoryRuns": 84607634,
                            "physicalQubitsForTfactories": 29221640,
                            "physicalQubitsForAlgorithm": 36291078,
                            "requiredLogicalQubitErrorRate": 3.2486263515087387e-16,
                            "requiredLogicalTstateErrorRate": 6.064616888655302e-12,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "7 days",
                        "rqops": "2.30G",
                        "physicalQubits": "65.51M",
                        "algorithmicLogicalQubits": "24.89k",
                        "algorithmicLogicalDepth": "55.65G",
                        "logicalDepth": "55.65G",
                        "numTstates": "74.20G",
                        "numTfactories": "877",
                        "numTfactoryRuns": "84.61M",
                        "physicalQubitsForAlgorithm": "36.29M",
                        "physicalQubitsForTfactories": "29.22M",
                        "physicalQubitsForTfactoriesPercentage": "44.60 %",
                        "requiredLogicalQubitErrorRate": "3.25e-16",
                        "requiredLogicalTstateErrorRate": "6.06e-12",
                        "physicalQubitsPerLogicalQubit": "1.46k",
                        "logicalCycleTime": "11 microsecs",
                        "clockFrequency": "92.59k",
                        "logicalErrorRate": "3.00e-16",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "129 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 21",
                        "physicalQubitsPerRound": "33.32k, 27.34k",
                        "tfactoryRuntimePerRound": "36 microsecs, 92 microsecs",
                        "tstateLogicalErrorRate": "2.47e-12",
                        "logicalCountsNumQubits": "12.29k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "18.55G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "65536000"
                    },
                    "logicalQubit": {
                        "codeDistance": 27,
                        "physicalQubits": 1458,
                        "logicalCycleTime": 10800,
                        "logicalErrorRate": 3.0000000000000044e-16
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 128800,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            21
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            27342
                        ],
                        "runtimePerRound": [
                            36400,
                            92400
                        ],
                        "logicalErrorRate": 2.4698959469631274e-12
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 12288,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 18550223710,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (10,800 nanosecs) multiplied by the 55,650,671,130 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 128,800 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (24,891) (with a logical error rate of 3.25e-16) multiplied by the clock frequency (92,592.59), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 36,291,078 physical qubits to implement the algorithm logic, and 29,221,640 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 12,288$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 24,891$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 18,550,223,710 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 55,650,671,130.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 11 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 18,550,223,710 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 74,200,894,840 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 877 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{74,200,894,840 \\cdot 128,800\\;\\text{ns}}{1 \\cdot 601,027,248,204,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 74,200,894,840 T states, the 877 copies of the T factory are repeatedly invoked 84,607,634 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 36,291,078 are the product of the 24,891 logical qubits after layout and the 1,458 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 877 in parallel, therefore we need $29,221,640 = 33,320 \\cdot 877$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 24,891 logical qubits and the total cycle count 55,650,671,130."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 74,200,894,840."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.00000000000000032486263515087387)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{27 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 10,800 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,458."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.47e-12."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 6.06e-12."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 24,891 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2808648000,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 131072000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 131053158,
                        "runtime": 601027248204000,
                        "rqops": 2304722223,
                        "breakdown": {
                            "algorithmicLogicalQubits": 24891,
                            "algorithmicLogicalDepth": 55650671130,
                            "logicalDepth": 55650671130,
                            "numTstates": 74200894840,
                            "clockFrequency": 92592.5925925926,
                            "numTfactories": 2844,
                            "numTfactoryRuns": 26090329,
                            "physicalQubitsForTfactories": 94762080,
                            "physicalQubitsForAlgorithm": 36291078,
                            "requiredLogicalQubitErrorRate": 3.2486263515087387e-16,
                            "requiredLogicalTstateErrorRate": 6.064616888655302e-12,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "7 days",
                        "rqops": "2.30G",
                        "physicalQubits": "131.05M",
                        "algorithmicLogicalQubits": "24.89k",
                        "algorithmicLogicalDepth": "55.65G",
                        "logicalDepth": "55.65G",
                        "numTstates": "74.20G",
                        "numTfactories": "2.84k",
                        "numTfactoryRuns": "26.09M",
                        "physicalQubitsForAlgorithm": "36.29M",
                        "physicalQubitsForTfactories": "94.76M",
                        "physicalQubitsForTfactoriesPercentage": "72.31 %",
                        "requiredLogicalQubitErrorRate": "3.25e-16",
                        "requiredLogicalTstateErrorRate": "6.06e-12",
                        "physicalQubitsPerLogicalQubit": "1.46k",
                        "logicalCycleTime": "11 microsecs",
                        "clockFrequency": "92.59k",
                        "logicalErrorRate": "3.00e-16",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "129 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 21",
                        "physicalQubitsPerRound": "33.32k, 27.34k",
                        "tfactoryRuntimePerRound": "36 microsecs, 92 microsecs",
                        "tstateLogicalErrorRate": "2.47e-12",
                        "logicalCountsNumQubits": "12.29k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "18.55G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "131072000"
                    },
                    "logicalQubit": {
                        "codeDistance": 27,
                        "physicalQubits": 1458,
                        "logicalCycleTime": 10800,
                        "logicalErrorRate": 3.0000000000000044e-16
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 128800,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            21
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            27342
                        ],
                        "runtimePerRound": [
                            36400,
                            92400
                        ],
                        "logicalErrorRate": 2.4698959469631274e-12
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 12288,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 18550223710,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (10,800 nanosecs) multiplied by the 55,650,671,130 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 128,800 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (24,891) (with a logical error rate of 3.25e-16) multiplied by the clock frequency (92,592.59), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 36,291,078 physical qubits to implement the algorithm logic, and 94,762,080 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 12,288$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 24,891$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 18,550,223,710 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 55,650,671,130.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 11 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 18,550,223,710 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 74,200,894,840 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 2,844 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{74,200,894,840 \\cdot 128,800\\;\\text{ns}}{1 \\cdot 601,027,248,204,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 74,200,894,840 T states, the 2,844 copies of the T factory are repeatedly invoked 26,090,329 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 36,291,078 are the product of the 24,891 logical qubits after layout and the 1,458 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 2,844 in parallel, therefore we need $94,762,080 = 33,320 \\cdot 2,844$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 24,891 logical qubits and the total cycle count 55,650,671,130."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 74,200,894,840."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.00000000000000032486263515087387)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{27 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 10,800 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,458."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.47e-12."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 6.06e-12."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 24,891 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2808648000,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 13107200,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 13103118,
                        "runtime": 434075234814000000,
                        "rqops": 3191154,
                        "breakdown": {
                            "algorithmicLogicalQubits": 24891,
                            "algorithmicLogicalDepth": 55650671130,
                            "logicalDepth": 55650671130,
                            "numTstates": 74200894840,
                            "clockFrequency": 128.2051282051282,
                            "numTfactories": 969,
                            "numTfactoryRuns": 76574711,
                            "physicalQubitsForTfactories": 4689960,
                            "physicalQubitsForAlgorithm": 8413158,
                            "requiredLogicalQubitErrorRate": 3.2486263515087387e-16,
                            "requiredLogicalTstateErrorRate": 6.064616888655302e-12,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "13 years",
                        "rqops": "3.19M",
                        "physicalQubits": "13.10M",
                        "algorithmicLogicalQubits": "24.89k",
                        "algorithmicLogicalDepth": "55.65G",
                        "logicalDepth": "55.65G",
                        "numTstates": "74.20G",
                        "numTfactories": "969",
                        "numTfactoryRuns": "76.57M",
                        "physicalQubitsForAlgorithm": "8.41M",
                        "physicalQubitsForTfactories": "4.69M",
                        "physicalQubitsForTfactoriesPercentage": "35.79 %",
                        "requiredLogicalQubitErrorRate": "3.25e-16",
                        "requiredLogicalTstateErrorRate": "6.06e-12",
                        "physicalQubitsPerLogicalQubit": "338",
                        "logicalCycleTime": "8 millisecs",
                        "clockFrequency": "128",
                        "logicalErrorRate": "3.00e-16",
                        "tfactoryPhysicalQubits": "4.84k",
                        "tfactoryRuntime": "86 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "11",
                        "physicalQubitsPerRound": "4.84k",
                        "tfactoryRuntimePerRound": "86 millisecs",
                        "tstateLogicalErrorRate": "2.13e-13",
                        "logicalCountsNumQubits": "12.29k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "18.55G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "13107200"
                    },
                    "logicalQubit": {
                        "codeDistance": 13,
                        "physicalQubits": 338,
                        "logicalCycleTime": 7800000,
                        "logicalErrorRate": 3.0000000000000004e-16
                    },
                    "tfactory": {
                        "physicalQubits": 4840,
                        "runtime": 85800000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            11
                        ],
                        "physicalQubitsPerRound": [
                            4840
                        ],
                        "runtimePerRound": [
                            85800000
                        ],
                        "logicalErrorRate": 2.1303499999999999e-13
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 12288,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 18550223710,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (7,800,000 nanosecs) multiplied by the 55,650,671,130 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 85,800,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (24,891) (with a logical error rate of 3.25e-16) multiplied by the clock frequency (128.21), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 8,413,158 physical qubits to implement the algorithm logic, and 4,689,960 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 12,288$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 24,891$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 18,550,223,710 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 55,650,671,130.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 8 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 18,550,223,710 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 74,200,894,840 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 969 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{74,200,894,840 \\cdot 85,800,000\\;\\text{ns}}{1 \\cdot 434,075,234,814,000,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 74,200,894,840 T states, the 969 copies of the T factory are repeatedly invoked 76,574,711 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 8,413,158 are the product of the 24,891 logical qubits after layout and the 338 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 4,840 physical qubits and we run 969 in parallel, therefore we need $4,689,960 = 4,840 \\cdot 969$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 24,891 logical qubits and the total cycle count 55,650,671,130."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 74,200,894,840."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.00000000000000032486263515087387)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{13 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 7,800,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 338."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-13."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 6.06e-12."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 24,891 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2871763200,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 262144000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 262134038,
                        "runtime": 601027248204000,
                        "rqops": 2304722223,
                        "breakdown": {
                            "algorithmicLogicalQubits": 24891,
                            "algorithmicLogicalDepth": 55650671130,
                            "logicalDepth": 55650671130,
                            "numTstates": 74200894840,
                            "clockFrequency": 92592.5925925926,
                            "numTfactories": 6778,
                            "numTfactoryRuns": 10947315,
                            "physicalQubitsForTfactories": 225842960,
                            "physicalQubitsForAlgorithm": 36291078,
                            "requiredLogicalQubitErrorRate": 3.2486263515087387e-16,
                            "requiredLogicalTstateErrorRate": 6.064616888655302e-12,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "7 days",
                        "rqops": "2.30G",
                        "physicalQubits": "262.13M",
                        "algorithmicLogicalQubits": "24.89k",
                        "algorithmicLogicalDepth": "55.65G",
                        "logicalDepth": "55.65G",
                        "numTstates": "74.20G",
                        "numTfactories": "6.78k",
                        "numTfactoryRuns": "10.95M",
                        "physicalQubitsForAlgorithm": "36.29M",
                        "physicalQubitsForTfactories": "225.84M",
                        "physicalQubitsForTfactoriesPercentage": "86.16 %",
                        "requiredLogicalQubitErrorRate": "3.25e-16",
                        "requiredLogicalTstateErrorRate": "6.06e-12",
                        "physicalQubitsPerLogicalQubit": "1.46k",
                        "logicalCycleTime": "11 microsecs",
                        "clockFrequency": "92.59k",
                        "logicalErrorRate": "3.00e-16",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "129 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 21",
                        "physicalQubitsPerRound": "33.32k, 27.34k",
                        "tfactoryRuntimePerRound": "36 microsecs, 92 microsecs",
                        "tstateLogicalErrorRate": "2.47e-12",
                        "logicalCountsNumQubits": "12.29k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "18.55G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "262144000"
                    },
                    "logicalQubit": {
                        "codeDistance": 27,
                        "physicalQubits": 1458,
                        "logicalCycleTime": 10800,
                        "logicalErrorRate": 3.0000000000000044e-16
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 128800,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            21
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            27342
                        ],
                        "runtimePerRound": [
                            36400,
                            92400
                        ],
                        "logicalErrorRate": 2.4698959469631274e-12
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 12288,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 18550223710,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (10,800 nanosecs) multiplied by the 55,650,671,130 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 128,800 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (24,891) (with a logical error rate of 3.25e-16) multiplied by the clock frequency (92,592.59), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 36,291,078 physical qubits to implement the algorithm logic, and 225,842,960 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 12,288$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 24,891$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 18,550,223,710 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 55,650,671,130.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 11 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 18,550,223,710 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 74,200,894,840 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 6,778 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{74,200,894,840 \\cdot 128,800\\;\\text{ns}}{1 \\cdot 601,027,248,204,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 74,200,894,840 T states, the 6,778 copies of the T factory are repeatedly invoked 10,947,315 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 36,291,078 are the product of the 24,891 logical qubits after layout and the 1,458 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 6,778 in parallel, therefore we need $225,842,960 = 33,320 \\cdot 6,778$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 24,891 logical qubits and the total cycle count 55,650,671,130."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 74,200,894,840."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.00000000000000032486263515087387)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{27 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 10,800 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,458."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.47e-12."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 6.06e-12."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 24,891 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2871763200,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 26214400,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 26209838,
                        "runtime": 434075234814000000,
                        "rqops": 3191154,
                        "breakdown": {
                            "algorithmicLogicalQubits": 24891,
                            "algorithmicLogicalDepth": 55650671130,
                            "logicalDepth": 55650671130,
                            "numTstates": 74200894840,
                            "clockFrequency": 128.2051282051282,
                            "numTfactories": 3677,
                            "numTfactoryRuns": 20179738,
                            "physicalQubitsForTfactories": 17796680,
                            "physicalQubitsForAlgorithm": 8413158,
                            "requiredLogicalQubitErrorRate": 3.2486263515087387e-16,
                            "requiredLogicalTstateErrorRate": 6.064616888655302e-12,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "13 years",
                        "rqops": "3.19M",
                        "physicalQubits": "26.21M",
                        "algorithmicLogicalQubits": "24.89k",
                        "algorithmicLogicalDepth": "55.65G",
                        "logicalDepth": "55.65G",
                        "numTstates": "74.20G",
                        "numTfactories": "3.68k",
                        "numTfactoryRuns": "20.18M",
                        "physicalQubitsForAlgorithm": "8.41M",
                        "physicalQubitsForTfactories": "17.80M",
                        "physicalQubitsForTfactoriesPercentage": "67.90 %",
                        "requiredLogicalQubitErrorRate": "3.25e-16",
                        "requiredLogicalTstateErrorRate": "6.06e-12",
                        "physicalQubitsPerLogicalQubit": "338",
                        "logicalCycleTime": "8 millisecs",
                        "clockFrequency": "128",
                        "logicalErrorRate": "3.00e-16",
                        "tfactoryPhysicalQubits": "4.84k",
                        "tfactoryRuntime": "86 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "11",
                        "physicalQubitsPerRound": "4.84k",
                        "tfactoryRuntimePerRound": "86 millisecs",
                        "tstateLogicalErrorRate": "2.13e-13",
                        "logicalCountsNumQubits": "12.29k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "18.55G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "26214400"
                    },
                    "logicalQubit": {
                        "codeDistance": 13,
                        "physicalQubits": 338,
                        "logicalCycleTime": 7800000,
                        "logicalErrorRate": 3.0000000000000004e-16
                    },
                    "tfactory": {
                        "physicalQubits": 4840,
                        "runtime": 85800000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            11
                        ],
                        "physicalQubitsPerRound": [
                            4840
                        ],
                        "runtimePerRound": [
                            85800000
                        ],
                        "logicalErrorRate": 2.1303499999999999e-13
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 12288,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 18550223710,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (7,800,000 nanosecs) multiplied by the 55,650,671,130 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 85,800,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (24,891) (with a logical error rate of 3.25e-16) multiplied by the clock frequency (128.21), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 8,413,158 physical qubits to implement the algorithm logic, and 17,796,680 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 12,288$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 24,891$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 18,550,223,710 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 55,650,671,130.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 8 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 18,550,223,710 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 74,200,894,840 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 3,677 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{74,200,894,840 \\cdot 85,800,000\\;\\text{ns}}{1 \\cdot 434,075,234,814,000,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 74,200,894,840 T states, the 3,677 copies of the T factory are repeatedly invoked 20,179,738 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 8,413,158 are the product of the 24,891 logical qubits after layout and the 338 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 4,840 physical qubits and we run 3,677 in parallel, therefore we need $17,796,680 = 4,840 \\cdot 3,677$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 24,891 logical qubits and the total cycle count 55,650,671,130."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 74,200,894,840."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.00000000000000032486263515087387)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{13 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 7,800,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 338."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-13."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 6.06e-12."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 24,891 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2934878400,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 524288000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 524262478,
                        "runtime": 601027248204000,
                        "rqops": 2304722223,
                        "breakdown": {
                            "algorithmicLogicalQubits": 24891,
                            "algorithmicLogicalDepth": 55650671130,
                            "logicalDepth": 55650671130,
                            "numTstates": 74200894840,
                            "clockFrequency": 92592.5925925926,
                            "numTfactories": 14645,
                            "numTfactoryRuns": 5066637,
                            "physicalQubitsForTfactories": 487971400,
                            "physicalQubitsForAlgorithm": 36291078,
                            "requiredLogicalQubitErrorRate": 3.2486263515087387e-16,
                            "requiredLogicalTstateErrorRate": 6.064616888655302e-12,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "7 days",
                        "rqops": "2.30G",
                        "physicalQubits": "524.26M",
                        "algorithmicLogicalQubits": "24.89k",
                        "algorithmicLogicalDepth": "55.65G",
                        "logicalDepth": "55.65G",
                        "numTstates": "74.20G",
                        "numTfactories": "14.64k",
                        "numTfactoryRuns": "5.07M",
                        "physicalQubitsForAlgorithm": "36.29M",
                        "physicalQubitsForTfactories": "487.97M",
                        "physicalQubitsForTfactoriesPercentage": "93.08 %",
                        "requiredLogicalQubitErrorRate": "3.25e-16",
                        "requiredLogicalTstateErrorRate": "6.06e-12",
                        "physicalQubitsPerLogicalQubit": "1.46k",
                        "logicalCycleTime": "11 microsecs",
                        "clockFrequency": "92.59k",
                        "logicalErrorRate": "3.00e-16",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "129 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 21",
                        "physicalQubitsPerRound": "33.32k, 27.34k",
                        "tfactoryRuntimePerRound": "36 microsecs, 92 microsecs",
                        "tstateLogicalErrorRate": "2.47e-12",
                        "logicalCountsNumQubits": "12.29k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "18.55G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "524288000"
                    },
                    "logicalQubit": {
                        "codeDistance": 27,
                        "physicalQubits": 1458,
                        "logicalCycleTime": 10800,
                        "logicalErrorRate": 3.0000000000000044e-16
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 128800,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            21
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            27342
                        ],
                        "runtimePerRound": [
                            36400,
                            92400
                        ],
                        "logicalErrorRate": 2.4698959469631274e-12
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 12288,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 18550223710,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (10,800 nanosecs) multiplied by the 55,650,671,130 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 128,800 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (24,891) (with a logical error rate of 3.25e-16) multiplied by the clock frequency (92,592.59), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 36,291,078 physical qubits to implement the algorithm logic, and 487,971,400 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 12,288$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 24,891$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 18,550,223,710 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 55,650,671,130.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 11 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 18,550,223,710 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 74,200,894,840 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 14,645 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{74,200,894,840 \\cdot 128,800\\;\\text{ns}}{1 \\cdot 601,027,248,204,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 74,200,894,840 T states, the 14,645 copies of the T factory are repeatedly invoked 5,066,637 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 36,291,078 are the product of the 24,891 logical qubits after layout and the 1,458 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 14,645 in parallel, therefore we need $487,971,400 = 33,320 \\cdot 14,645$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 24,891 logical qubits and the total cycle count 55,650,671,130."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 74,200,894,840."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.00000000000000032486263515087387)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{27 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 10,800 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,458."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.47e-12."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 6.06e-12."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 24,891 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2934878400,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 52428800,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 52428118,
                        "runtime": 434075234814000000,
                        "rqops": 3191154,
                        "breakdown": {
                            "algorithmicLogicalQubits": 24891,
                            "algorithmicLogicalDepth": 55650671130,
                            "logicalDepth": 55650671130,
                            "numTstates": 74200894840,
                            "clockFrequency": 128.2051282051282,
                            "numTfactories": 9094,
                            "numTfactoryRuns": 8159325,
                            "physicalQubitsForTfactories": 44014960,
                            "physicalQubitsForAlgorithm": 8413158,
                            "requiredLogicalQubitErrorRate": 3.2486263515087387e-16,
                            "requiredLogicalTstateErrorRate": 6.064616888655302e-12,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "13 years",
                        "rqops": "3.19M",
                        "physicalQubits": "52.43M",
                        "algorithmicLogicalQubits": "24.89k",
                        "algorithmicLogicalDepth": "55.65G",
                        "logicalDepth": "55.65G",
                        "numTstates": "74.20G",
                        "numTfactories": "9.09k",
                        "numTfactoryRuns": "8.16M",
                        "physicalQubitsForAlgorithm": "8.41M",
                        "physicalQubitsForTfactories": "44.01M",
                        "physicalQubitsForTfactoriesPercentage": "83.95 %",
                        "requiredLogicalQubitErrorRate": "3.25e-16",
                        "requiredLogicalTstateErrorRate": "6.06e-12",
                        "physicalQubitsPerLogicalQubit": "338",
                        "logicalCycleTime": "8 millisecs",
                        "clockFrequency": "128",
                        "logicalErrorRate": "3.00e-16",
                        "tfactoryPhysicalQubits": "4.84k",
                        "tfactoryRuntime": "86 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "11",
                        "physicalQubitsPerRound": "4.84k",
                        "tfactoryRuntimePerRound": "86 millisecs",
                        "tstateLogicalErrorRate": "2.13e-13",
                        "logicalCountsNumQubits": "12.29k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "18.55G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "52428800"
                    },
                    "logicalQubit": {
                        "codeDistance": 13,
                        "physicalQubits": 338,
                        "logicalCycleTime": 7800000,
                        "logicalErrorRate": 3.0000000000000004e-16
                    },
                    "tfactory": {
                        "physicalQubits": 4840,
                        "runtime": 85800000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            11
                        ],
                        "physicalQubitsPerRound": [
                            4840
                        ],
                        "runtimePerRound": [
                            85800000
                        ],
                        "logicalErrorRate": 2.1303499999999999e-13
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 12288,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 18550223710,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (7,800,000 nanosecs) multiplied by the 55,650,671,130 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 85,800,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (24,891) (with a logical error rate of 3.25e-16) multiplied by the clock frequency (128.21), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 8,413,158 physical qubits to implement the algorithm logic, and 44,014,960 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 12,288$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 24,891$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 18,550,223,710 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 55,650,671,130.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 8 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 18,550,223,710 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 74,200,894,840 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 9,094 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{74,200,894,840 \\cdot 85,800,000\\;\\text{ns}}{1 \\cdot 434,075,234,814,000,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 74,200,894,840 T states, the 9,094 copies of the T factory are repeatedly invoked 8,159,325 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 8,413,158 are the product of the 24,891 logical qubits after layout and the 338 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 4,840 physical qubits and we run 9,094 in parallel, therefore we need $44,014,960 = 4,840 \\cdot 9,094$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 24,891 logical qubits and the total cycle count 55,650,671,130."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 74,200,894,840."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.00000000000000032486263515087387)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{13 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 7,800,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 338."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-13."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 6.06e-12."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 24,891 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            }
        ]
    },
    {
        "protocol": "RSA-8192",
        "threats": [
            {
                "timestamp": 2808648000,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 131072000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 131044474,
                        "runtime": 5214384062301600,
                        "rqops": 3999758065,
                        "breakdown": {
                            "algorithmicLogicalQubits": 49597,
                            "algorithmicLogicalDepth": 420514843734,
                            "logicalDepth": 420514843734,
                            "numTstates": 560686458312,
                            "clockFrequency": 80645.16129032258,
                            "numTfactories": 1072,
                            "numTfactoryRuns": 523028413,
                            "physicalQubitsForTfactories": 35719040,
                            "physicalQubitsForAlgorithm": 95325434,
                            "requiredLogicalQubitErrorRate": 2.157624054976255e-17,
                            "requiredLogicalTstateErrorRate": 8.0258760190993e-13,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "60 days",
                        "rqops": "4.00G",
                        "physicalQubits": "131.04M",
                        "algorithmicLogicalQubits": "49.60k",
                        "algorithmicLogicalDepth": "420.51G",
                        "logicalDepth": "420.51G",
                        "numTstates": "560.69G",
                        "numTfactories": "1.07k",
                        "numTfactoryRuns": "523.03M",
                        "physicalQubitsForAlgorithm": "95.33M",
                        "physicalQubitsForTfactories": "35.72M",
                        "physicalQubitsForTfactoriesPercentage": "27.26 %",
                        "requiredLogicalQubitErrorRate": "2.16e-17",
                        "requiredLogicalTstateErrorRate": "8.03e-13",
                        "physicalQubitsPerLogicalQubit": "1.92k",
                        "logicalCycleTime": "12 microsecs",
                        "clockFrequency": "80.64k",
                        "logicalErrorRate": "3.00e-18",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "138 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 23",
                        "physicalQubitsPerRound": "33.32k, 32.80k",
                        "tfactoryRuntimePerRound": "36 microsecs, 101 microsecs",
                        "tstateLogicalErrorRate": "5.53e-13",
                        "logicalCountsNumQubits": "24.58k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "140.17G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "131072000"
                    },
                    "logicalQubit": {
                        "codeDistance": 31,
                        "physicalQubits": 1922,
                        "logicalCycleTime": 12400,
                        "logicalErrorRate": 3.000000000000005e-18
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 137600,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            23
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            32798
                        ],
                        "runtimePerRound": [
                            36400,
                            101200
                        ],
                        "logicalErrorRate": 5.528959469631257e-13
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 24576,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 140171614578,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (12,400 nanosecs) multiplied by the 420,514,843,734 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 137,600 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (49,597) (with a logical error rate of 2.16e-17) multiplied by the clock frequency (80,645.16), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 95,325,434 physical qubits to implement the algorithm logic, and 35,719,040 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 24,576$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 49,597$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 140,171,614,578 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 420,514,843,734.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 12 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 140,171,614,578 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 560,686,458,312 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 1,072 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{560,686,458,312 \\cdot 137,600\\;\\text{ns}}{1 \\cdot 5,214,384,062,301,600\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 560,686,458,312 T states, the 1,072 copies of the T factory are repeatedly invoked 523,028,413 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 95,325,434 are the product of the 49,597 logical qubits after layout and the 1,922 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 1,072 in parallel, therefore we need $35,719,040 = 33,320 \\cdot 1,072$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 49,597 logical qubits and the total cycle count 420,514,843,734."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 560,686,458,312."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.00000000000000002157624054976255)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{31 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 12,400 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,922."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 5.53e-13."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 8.03e-13."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 49,597 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2871763200,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 262144000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 262125354,
                        "runtime": 5214384062301600,
                        "rqops": 3999758065,
                        "breakdown": {
                            "algorithmicLogicalQubits": 49597,
                            "algorithmicLogicalDepth": 420514843734,
                            "logicalDepth": 420514843734,
                            "numTstates": 560686458312,
                            "clockFrequency": 80645.16129032258,
                            "numTfactories": 5006,
                            "numTfactoryRuns": 112002889,
                            "physicalQubitsForTfactories": 166799920,
                            "physicalQubitsForAlgorithm": 95325434,
                            "requiredLogicalQubitErrorRate": 2.157624054976255e-17,
                            "requiredLogicalTstateErrorRate": 8.0258760190993e-13,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "60 days",
                        "rqops": "4.00G",
                        "physicalQubits": "262.13M",
                        "algorithmicLogicalQubits": "49.60k",
                        "algorithmicLogicalDepth": "420.51G",
                        "logicalDepth": "420.51G",
                        "numTstates": "560.69G",
                        "numTfactories": "5.01k",
                        "numTfactoryRuns": "112.00M",
                        "physicalQubitsForAlgorithm": "95.33M",
                        "physicalQubitsForTfactories": "166.80M",
                        "physicalQubitsForTfactoriesPercentage": "63.63 %",
                        "requiredLogicalQubitErrorRate": "2.16e-17",
                        "requiredLogicalTstateErrorRate": "8.03e-13",
                        "physicalQubitsPerLogicalQubit": "1.92k",
                        "logicalCycleTime": "12 microsecs",
                        "clockFrequency": "80.64k",
                        "logicalErrorRate": "3.00e-18",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "138 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 23",
                        "physicalQubitsPerRound": "33.32k, 32.80k",
                        "tfactoryRuntimePerRound": "36 microsecs, 101 microsecs",
                        "tstateLogicalErrorRate": "5.53e-13",
                        "logicalCountsNumQubits": "24.58k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "140.17G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "262144000"
                    },
                    "logicalQubit": {
                        "codeDistance": 31,
                        "physicalQubits": 1922,
                        "logicalCycleTime": 12400,
                        "logicalErrorRate": 3.000000000000005e-18
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 137600,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            23
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            32798
                        ],
                        "runtimePerRound": [
                            36400,
                            101200
                        ],
                        "logicalErrorRate": 5.528959469631257e-13
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 24576,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 140171614578,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (12,400 nanosecs) multiplied by the 420,514,843,734 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 137,600 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (49,597) (with a logical error rate of 2.16e-17) multiplied by the clock frequency (80,645.16), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 95,325,434 physical qubits to implement the algorithm logic, and 166,799,920 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 24,576$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 49,597$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 140,171,614,578 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 420,514,843,734.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 12 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 140,171,614,578 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 560,686,458,312 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 5,006 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{560,686,458,312 \\cdot 137,600\\;\\text{ns}}{1 \\cdot 5,214,384,062,301,600\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 560,686,458,312 T states, the 5,006 copies of the T factory are repeatedly invoked 112,002,889 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 95,325,434 are the product of the 49,597 logical qubits after layout and the 1,922 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 5,006 in parallel, therefore we need $166,799,920 = 33,320 \\cdot 5,006$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 49,597 logical qubits and the total cycle count 420,514,843,734."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 560,686,458,312."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.00000000000000002157624054976255)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{31 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 12,400 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,922."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 5.53e-13."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 8.03e-13."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 49,597 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2871763200,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 26214400,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 26210010,
                        "runtime": 3784633593606000000,
                        "rqops": 5510778,
                        "breakdown": {
                            "algorithmicLogicalQubits": 49597,
                            "algorithmicLogicalDepth": 420514843734,
                            "logicalDepth": 420514843734,
                            "numTstates": 560686458312,
                            "clockFrequency": 111.11111111111111,
                            "numTfactories": 804,
                            "numTfactoryRuns": 697371217,
                            "physicalQubitsForTfactories": 3891360,
                            "physicalQubitsForAlgorithm": 22318650,
                            "requiredLogicalQubitErrorRate": 2.157624054976255e-17,
                            "requiredLogicalTstateErrorRate": 8.0258760190993e-13,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "120 years",
                        "rqops": "5.51M",
                        "physicalQubits": "26.21M",
                        "algorithmicLogicalQubits": "49.60k",
                        "algorithmicLogicalDepth": "420.51G",
                        "logicalDepth": "420.51G",
                        "numTstates": "560.69G",
                        "numTfactories": "804",
                        "numTfactoryRuns": "697.37M",
                        "physicalQubitsForAlgorithm": "22.32M",
                        "physicalQubitsForTfactories": "3.89M",
                        "physicalQubitsForTfactoriesPercentage": "14.85 %",
                        "requiredLogicalQubitErrorRate": "2.16e-17",
                        "requiredLogicalTstateErrorRate": "8.03e-13",
                        "physicalQubitsPerLogicalQubit": "450",
                        "logicalCycleTime": "9 millisecs",
                        "clockFrequency": "111",
                        "logicalErrorRate": "3.00e-18",
                        "tfactoryPhysicalQubits": "4.84k",
                        "tfactoryRuntime": "86 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "11",
                        "physicalQubitsPerRound": "4.84k",
                        "tfactoryRuntimePerRound": "86 millisecs",
                        "tstateLogicalErrorRate": "2.13e-13",
                        "logicalCountsNumQubits": "24.58k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "140.17G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "26214400"
                    },
                    "logicalQubit": {
                        "codeDistance": 15,
                        "physicalQubits": 450,
                        "logicalCycleTime": 9000000,
                        "logicalErrorRate": 3.0000000000000002e-18
                    },
                    "tfactory": {
                        "physicalQubits": 4840,
                        "runtime": 85800000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            11
                        ],
                        "physicalQubitsPerRound": [
                            4840
                        ],
                        "runtimePerRound": [
                            85800000
                        ],
                        "logicalErrorRate": 2.1303499999999999e-13
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 24576,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 140171614578,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (9,000,000 nanosecs) multiplied by the 420,514,843,734 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 85,800,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (49,597) (with a logical error rate of 2.16e-17) multiplied by the clock frequency (111.11), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 22,318,650 physical qubits to implement the algorithm logic, and 3,891,360 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 24,576$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 49,597$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 140,171,614,578 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 420,514,843,734.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 9 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 140,171,614,578 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 560,686,458,312 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 804 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{560,686,458,312 \\cdot 85,800,000\\;\\text{ns}}{1 \\cdot 3,784,633,593,606,000,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 560,686,458,312 T states, the 804 copies of the T factory are repeatedly invoked 697,371,217 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 22,318,650 are the product of the 49,597 logical qubits after layout and the 450 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 4,840 physical qubits and we run 804 in parallel, therefore we need $3,891,360 = 4,840 \\cdot 804$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 49,597 logical qubits and the total cycle count 420,514,843,734."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 560,686,458,312."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.00000000000000002157624054976255)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{15 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 9,000,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 450."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-13."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 8.03e-13."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 49,597 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2934878400,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 524288000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 524287114,
                        "runtime": 5214384062301600,
                        "rqops": 3999758065,
                        "breakdown": {
                            "algorithmicLogicalQubits": 49597,
                            "algorithmicLogicalDepth": 420514843734,
                            "logicalDepth": 420514843734,
                            "numTstates": 560686458312,
                            "clockFrequency": 80645.16129032258,
                            "numTfactories": 12874,
                            "numTfactoryRuns": 43551846,
                            "physicalQubitsForTfactories": 428961680,
                            "physicalQubitsForAlgorithm": 95325434,
                            "requiredLogicalQubitErrorRate": 2.157624054976255e-17,
                            "requiredLogicalTstateErrorRate": 8.0258760190993e-13,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "60 days",
                        "rqops": "4.00G",
                        "physicalQubits": "524.29M",
                        "algorithmicLogicalQubits": "49.60k",
                        "algorithmicLogicalDepth": "420.51G",
                        "logicalDepth": "420.51G",
                        "numTstates": "560.69G",
                        "numTfactories": "12.87k",
                        "numTfactoryRuns": "43.55M",
                        "physicalQubitsForAlgorithm": "95.33M",
                        "physicalQubitsForTfactories": "428.96M",
                        "physicalQubitsForTfactoriesPercentage": "81.82 %",
                        "requiredLogicalQubitErrorRate": "2.16e-17",
                        "requiredLogicalTstateErrorRate": "8.03e-13",
                        "physicalQubitsPerLogicalQubit": "1.92k",
                        "logicalCycleTime": "12 microsecs",
                        "clockFrequency": "80.64k",
                        "logicalErrorRate": "3.00e-18",
                        "tfactoryPhysicalQubits": "33.32k",
                        "tfactoryRuntime": "138 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "7, 23",
                        "physicalQubitsPerRound": "33.32k, 32.80k",
                        "tfactoryRuntimePerRound": "36 microsecs, 101 microsecs",
                        "tstateLogicalErrorRate": "5.53e-13",
                        "logicalCountsNumQubits": "24.58k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "140.17G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "524288000"
                    },
                    "logicalQubit": {
                        "codeDistance": 31,
                        "physicalQubits": 1922,
                        "logicalCycleTime": 12400,
                        "logicalErrorRate": 3.000000000000005e-18
                    },
                    "tfactory": {
                        "physicalQubits": 33320,
                        "runtime": 137600,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            7,
                            23
                        ],
                        "physicalQubitsPerRound": [
                            33320,
                            32798
                        ],
                        "runtimePerRound": [
                            36400,
                            101200
                        ],
                        "logicalErrorRate": 5.528959469631257e-13
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 24576,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 140171614578,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (12,400 nanosecs) multiplied by the 420,514,843,734 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 137,600 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (49,597) (with a logical error rate of 2.16e-17) multiplied by the clock frequency (80,645.16), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 95,325,434 physical qubits to implement the algorithm logic, and 428,961,680 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 24,576$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 49,597$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 140,171,614,578 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 420,514,843,734.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 12 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 140,171,614,578 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 560,686,458,312 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 12,874 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{560,686,458,312 \\cdot 137,600\\;\\text{ns}}{1 \\cdot 5,214,384,062,301,600\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 560,686,458,312 T states, the 12,874 copies of the T factory are repeatedly invoked 43,551,846 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 95,325,434 are the product of the 49,597 logical qubits after layout and the 1,922 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 33,320 physical qubits and we run 12,874 in parallel, therefore we need $428,961,680 = 33,320 \\cdot 12,874$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 49,597 logical qubits and the total cycle count 420,514,843,734."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 560,686,458,312."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.00000000000000002157624054976255)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{31 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 12,400 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 1,922."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 5.53e-13."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 8.03e-13."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 49,597 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2934878400,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_us_e4",
                            "oneQubitMeasurementTime": "100000 ns",
                            "oneQubitGateTime": "100000 ns",
                            "twoQubitGateTime": "100000 ns",
                            "tGateTime": "100000 ns",
                            "oneQubitMeasurementErrorRate": 0.0001,
                            "oneQubitGateErrorRate": 0.0001,
                            "twoQubitGateErrorRate": 0.0001,
                            "tGateErrorRate": 1e-06,
                            "idleErrorRate": 0.0001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 52428800,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 52428290,
                        "runtime": 3784633593606000000,
                        "rqops": 5510778,
                        "breakdown": {
                            "algorithmicLogicalQubits": 49597,
                            "algorithmicLogicalDepth": 420514843734,
                            "logicalDepth": 420514843734,
                            "numTstates": 560686458312,
                            "clockFrequency": 111.11111111111111,
                            "numTfactories": 6221,
                            "numTfactoryRuns": 90128028,
                            "physicalQubitsForTfactories": 30109640,
                            "physicalQubitsForAlgorithm": 22318650,
                            "requiredLogicalQubitErrorRate": 2.157624054976255e-17,
                            "requiredLogicalTstateErrorRate": 8.0258760190993e-13,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.0001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "120 years",
                        "rqops": "5.51M",
                        "physicalQubits": "52.43M",
                        "algorithmicLogicalQubits": "49.60k",
                        "algorithmicLogicalDepth": "420.51G",
                        "logicalDepth": "420.51G",
                        "numTstates": "560.69G",
                        "numTfactories": "6.22k",
                        "numTfactoryRuns": "90.13M",
                        "physicalQubitsForAlgorithm": "22.32M",
                        "physicalQubitsForTfactories": "30.11M",
                        "physicalQubitsForTfactoriesPercentage": "57.43 %",
                        "requiredLogicalQubitErrorRate": "2.16e-17",
                        "requiredLogicalTstateErrorRate": "8.03e-13",
                        "physicalQubitsPerLogicalQubit": "450",
                        "logicalCycleTime": "9 millisecs",
                        "clockFrequency": "111",
                        "logicalErrorRate": "3.00e-18",
                        "tfactoryPhysicalQubits": "4.84k",
                        "tfactoryRuntime": "86 millisecs",
                        "numInputTstates": "15",
                        "numUnitsPerRound": "1",
                        "unitNamePerRound": "15-to-1 space efficient",
                        "codeDistancePerRound": "11",
                        "physicalQubitsPerRound": "4.84k",
                        "tfactoryRuntimePerRound": "86 millisecs",
                        "tstateLogicalErrorRate": "2.13e-13",
                        "logicalCountsNumQubits": "24.58k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "140.17G",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "52428800"
                    },
                    "logicalQubit": {
                        "codeDistance": 15,
                        "physicalQubits": 450,
                        "logicalCycleTime": 9000000,
                        "logicalErrorRate": 3.0000000000000002e-18
                    },
                    "tfactory": {
                        "physicalQubits": 4840,
                        "runtime": 85800000,
                        "numTstates": 1,
                        "numInputTstates": 15,
                        "numRounds": 1,
                        "numUnitsPerRound": [
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient"
                        ],
                        "codeDistancePerRound": [
                            11
                        ],
                        "physicalQubitsPerRound": [
                            4840
                        ],
                        "runtimePerRound": [
                            85800000
                        ],
                        "logicalErrorRate": 2.1303499999999999e-13
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 24576,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 140171614578,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (9,000,000 nanosecs) multiplied by the 420,514,843,734 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 85,800,000 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (49,597) (with a logical error rate of 2.16e-17) multiplied by the clock frequency (111.11), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 22,318,650 physical qubits to implement the algorithm logic, and 30,109,640 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 24,576$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 49,597$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 140,171,614,578 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 420,514,843,734.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 9 millisecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 140,171,614,578 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 560,686,458,312 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 6,221 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{560,686,458,312 \\cdot 85,800,000\\;\\text{ns}}{1 \\cdot 3,784,633,593,606,000,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 560,686,458,312 T states, the 6,221 copies of the T factory are repeatedly invoked 90,128,028 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 22,318,650 are the product of the 49,597 logical qubits after layout and the 450 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 4,840 physical qubits and we run 6,221 in parallel, therefore we need $30,109,640 = 4,840 \\cdot 6,221$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 49,597 logical qubits and the total cycle count 420,514,843,734."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 560,686,458,312."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.00000000000000002157624054976255)}{\\log(0.01/0.0001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.0001}{0.01}\\right)^\\frac{15 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 9,000,000 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 450."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 15 noisy physical T states with an error rate of 0.000001 and produces 1 T states with an error rate of 2.13e-13."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 8.03e-13."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 49,597 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            }
        ]
    },
    {
        "protocol": "RSA-16384",
        "threats": [
            {
                "timestamp": 2871763200,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 262144000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 262128834,
                        "runtime": 43102701681336000,
                        "rqops": 7494924243,
                        "breakdown": {
                            "algorithmicLogicalQubits": 98933,
                            "algorithmicLogicalDepth": 3265356187980,
                            "logicalDepth": 3265356187980,
                            "numTstates": 4353808250640,
                            "clockFrequency": 75757.57575757576,
                            "numTfactories": 847,
                            "numTfactoryRuns": 5140269482,
                            "physicalQubitsForTfactories": 46652760,
                            "physicalQubitsForAlgorithm": 215476074,
                            "requiredLogicalQubitErrorRate": 1.3929668261626498e-18,
                            "requiredLogicalTstateErrorRate": 1.0335779025956208e-13,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "1 years",
                        "rqops": "7.49G",
                        "physicalQubits": "262.13M",
                        "algorithmicLogicalQubits": "98.93k",
                        "algorithmicLogicalDepth": "3.27T",
                        "logicalDepth": "3.27T",
                        "numTstates": "4.35T",
                        "numTfactories": "847",
                        "numTfactoryRuns": "5.14G",
                        "physicalQubitsForAlgorithm": "215.48M",
                        "physicalQubitsForTfactories": "46.65M",
                        "physicalQubitsForTfactoriesPercentage": "17.80 %",
                        "requiredLogicalQubitErrorRate": "1.39e-18",
                        "requiredLogicalTstateErrorRate": "1.03e-13",
                        "physicalQubitsPerLogicalQubit": "2.18k",
                        "logicalCycleTime": "13 microsecs",
                        "clockFrequency": "75.76k",
                        "logicalErrorRate": "3.00e-19",
                        "tfactoryPhysicalQubits": "55.08k",
                        "tfactoryRuntime": "157 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "9, 25",
                        "physicalQubitsPerRound": "55.08k, 38.75k",
                        "tfactoryRuntimePerRound": "47 microsecs, 110 microsecs",
                        "tstateLogicalErrorRate": "2.17e-14",
                        "logicalCountsNumQubits": "49.15k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "1.09T",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "262144000"
                    },
                    "logicalQubit": {
                        "codeDistance": 33,
                        "physicalQubits": 2178,
                        "logicalCycleTime": 13200,
                        "logicalErrorRate": 3.000000000000005e-19
                    },
                    "tfactory": {
                        "physicalQubits": 55080,
                        "runtime": 156800,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            9,
                            25
                        ],
                        "physicalQubitsPerRound": [
                            55080,
                            38750
                        ],
                        "runtimePerRound": [
                            46800,
                            110000
                        ],
                        "logicalErrorRate": 2.165517447437503e-14
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 49152,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 1088452062660,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (13,200 nanosecs) multiplied by the 3,265,356,187,980 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 156,800 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (98,933) (with a logical error rate of 1.39e-18) multiplied by the clock frequency (75,757.58), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 215,476,074 physical qubits to implement the algorithm logic, and 46,652,760 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 49,152$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 98,933$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 1,088,452,062,660 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 3,265,356,187,980.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 13 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 1,088,452,062,660 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 4,353,808,250,640 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 847 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{4,353,808,250,640 \\cdot 156,800\\;\\text{ns}}{1 \\cdot 43,102,701,681,336,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 4,353,808,250,640 T states, the 847 copies of the T factory are repeatedly invoked 5,140,269,482 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 215,476,074 are the product of the 98,933 logical qubits after layout and the 2,178 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 55,080 physical qubits and we run 847 in parallel, therefore we need $46,652,760 = 55,080 \\cdot 847$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 98,933 logical qubits and the total cycle count 3,265,356,187,980."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 4,353,808,250,640."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000000000013929668261626498)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{33 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 13,200 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 2,178."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.17e-14."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.03e-13."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 98,933 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            },
            {
                "timestamp": 2934878400,
                "estimatorResult": {
                    "status": "success",
                    "jobParams": {
                        "qecScheme": {
                            "name": "surface_code",
                            "errorCorrectionThreshold": 0.01,
                            "crossingPrefactor": 0.03,
                            "logicalCycleTime": "(4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance",
                            "physicalQubitsPerLogicalQubit": "2 * codeDistance * codeDistance",
                            "maxCodeDistance": 50
                        },
                        "errorBudget": 0.9,
                        "qubitParams": {
                            "instructionSet": "GateBased",
                            "name": "qubit_gate_ns_e3",
                            "oneQubitMeasurementTime": "100 ns",
                            "oneQubitGateTime": "50 ns",
                            "twoQubitGateTime": "50 ns",
                            "tGateTime": "50 ns",
                            "oneQubitMeasurementErrorRate": 0.001,
                            "oneQubitGateErrorRate": 0.001,
                            "twoQubitGateErrorRate": 0.001,
                            "tGateErrorRate": 0.001,
                            "idleErrorRate": 0.001
                        },
                        "constraints": {
                            "maxPhysicalQubits": 524288000,
                            "maxDistillationRounds": 3
                        },
                        "estimateType": "singlePoint"
                    },
                    "physicalCounts": {
                        "physicalQubits": 524254554,
                        "runtime": 43102701681336000,
                        "rqops": 7494924243,
                        "breakdown": {
                            "algorithmicLogicalQubits": 98933,
                            "algorithmicLogicalDepth": 3265356187980,
                            "logicalDepth": 3265356187980,
                            "numTstates": 4353808250640,
                            "clockFrequency": 75757.57575757576,
                            "numTfactories": 5606,
                            "numTfactoryRuns": 776633652,
                            "physicalQubitsForTfactories": 308778480,
                            "physicalQubitsForAlgorithm": 215476074,
                            "requiredLogicalQubitErrorRate": 1.3929668261626498e-18,
                            "requiredLogicalTstateErrorRate": 1.0335779025956208e-13,
                            "numTsPerRotation": null,
                            "cliffordErrorRate": 0.001
                        }
                    },
                    "physicalCountsFormatted": {
                        "runtime": "1 years",
                        "rqops": "7.49G",
                        "physicalQubits": "524.25M",
                        "algorithmicLogicalQubits": "98.93k",
                        "algorithmicLogicalDepth": "3.27T",
                        "logicalDepth": "3.27T",
                        "numTstates": "4.35T",
                        "numTfactories": "5.61k",
                        "numTfactoryRuns": "776.63M",
                        "physicalQubitsForAlgorithm": "215.48M",
                        "physicalQubitsForTfactories": "308.78M",
                        "physicalQubitsForTfactoriesPercentage": "58.90 %",
                        "requiredLogicalQubitErrorRate": "1.39e-18",
                        "requiredLogicalTstateErrorRate": "1.03e-13",
                        "physicalQubitsPerLogicalQubit": "2.18k",
                        "logicalCycleTime": "13 microsecs",
                        "clockFrequency": "75.76k",
                        "logicalErrorRate": "3.00e-19",
                        "tfactoryPhysicalQubits": "55.08k",
                        "tfactoryRuntime": "157 microsecs",
                        "numInputTstates": "255",
                        "numUnitsPerRound": "17, 1",
                        "unitNamePerRound": "15-to-1 space efficient, 15-to-1 RM prep",
                        "codeDistancePerRound": "9, 25",
                        "physicalQubitsPerRound": "55.08k, 38.75k",
                        "tfactoryRuntimePerRound": "47 microsecs, 110 microsecs",
                        "tstateLogicalErrorRate": "2.17e-14",
                        "logicalCountsNumQubits": "49.15k",
                        "logicalCountsTCount": "0",
                        "logicalCountsRotationCount": "0",
                        "logicalCountsRotationDepth": "0",
                        "logicalCountsCczCount": "1.09T",
                        "logicalCountsCcixCount": "0",
                        "logicalCountsMeasurementCount": "0",
                        "errorBudget": "9.00e-1",
                        "errorBudgetLogical": "4.50e-1",
                        "errorBudgetTstates": "4.50e-1",
                        "errorBudgetRotations": "0.00e0",
                        "numTsPerRotation": "No rotations in algorithm",
                        "logicalDepthFactor": "constraint not set",
                        "maxTFactories": "constraint not set",
                        "maxDuration": "constraint not set",
                        "maxPhysicalQubits": "524288000"
                    },
                    "logicalQubit": {
                        "codeDistance": 33,
                        "physicalQubits": 2178,
                        "logicalCycleTime": 13200,
                        "logicalErrorRate": 3.000000000000005e-19
                    },
                    "tfactory": {
                        "physicalQubits": 55080,
                        "runtime": 156800,
                        "numTstates": 1,
                        "numInputTstates": 255,
                        "numRounds": 2,
                        "numUnitsPerRound": [
                            17,
                            1
                        ],
                        "unitNamePerRound": [
                            "15-to-1 space efficient",
                            "15-to-1 RM prep"
                        ],
                        "codeDistancePerRound": [
                            9,
                            25
                        ],
                        "physicalQubitsPerRound": [
                            55080,
                            38750
                        ],
                        "runtimePerRound": [
                            46800,
                            110000
                        ],
                        "logicalErrorRate": 2.165517447437503e-14
                    },
                    "errorBudget": {
                        "logical": 0.45,
                        "tstates": 0.45,
                        "rotations": 0.0
                    },
                    "logicalCounts": {
                        "numQubits": 49152,
                        "tCount": 0,
                        "rotationCount": 0,
                        "rotationDepth": 0,
                        "cczCount": 1088452062660,
                        "ccixCount": 0,
                        "measurementCount": 0
                    },
                    "reportData": {
                        "groups": [
                            {
                                "title": "Physical resource estimates",
                                "alwaysVisible": true,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/runtime",
                                        "label": "Runtime",
                                        "description": "Total runtime",
                                        "explanation": "This is a runtime estimate for the execution time of the algorithm.  In general, the execution time corresponds to the duration of one logical cycle (13,200 nanosecs) multiplied by the 3,265,356,187,980 logical cycles to run the algorithm.  If however the duration of a single T factory (here: 156,800 nanosecs) is larger than the algorithm runtime, we extend the number of logical cycles artificially in order to exceed the runtime of a single T factory."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/rqops",
                                        "label": "rQOPS",
                                        "description": "Reliable quantum operations per second",
                                        "explanation": "The value is computed as the number of logical qubits after layout (98,933) (with a logical error rate of 1.39e-18) multiplied by the clock frequency (75,757.58), which is the number of logical cycles per second."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits",
                                        "explanation": "This value represents the total number of physical qubits, which is the sum of 215,476,074 physical qubits to implement the algorithm logic, and 308,778,480 physical qubits to execute the T factories that are responsible to produce the T states that are consumed by the algorithm."
                                    }
                                ]
                            },
                            {
                                "title": "Resource estimates breakdown",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalQubits",
                                        "label": "Logical algorithmic qubits",
                                        "description": "Number of logical qubits for the algorithm after layout",
                                        "explanation": "Laying out the logical qubits in the presence of nearest-neighbor constraints requires additional logical qubits.  In particular, to layout the $Q_{\\rm alg} = 49,152$ logical qubits in the input algorithm, we require in total $2 \\cdot Q_{\\rm alg} + \\lceil \\sqrt{8 \\cdot Q_{\\rm alg}}\\rceil + 1 = 98,933$ logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/algorithmicLogicalDepth",
                                        "label": "Algorithmic depth",
                                        "description": "Number of logical cycles for the algorithm",
                                        "explanation": "To execute the algorithm using _Parallel Synthesis Sequential Pauli Computation_ (PSSPC), operations are scheduled in terms of multi-qubit Pauli measurements, for which assume an execution time of one logical cycle.  Based on the input algorithm, we require one multi-qubit measurement for the 0 single-qubit measurements, the 0 arbitrary single-qubit rotations, and the 0 T gates, three multi-qubit measurements for each of the 1,088,452,062,660 CCZ and 0 CCiX gates in the input program, as well as No rotations in algorithm multi-qubit measurements for each of the 0 non-Clifford layers in which there is at least one single-qubit rotation with an arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalDepth",
                                        "label": "Logical depth",
                                        "description": "Number of logical cycles performed",
                                        "explanation": "This number is usually equal to the logical depth of the algorithm, which is 3,265,356,187,980.  However, in the case in which a single T factory is slower than the execution time of the algorithm, we adjust the logical cycle depth to exceed the T factory's execution time."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/clockFrequency",
                                        "label": "Clock frequency",
                                        "description": "Number of logical cycles per second",
                                        "explanation": "This is the number of logical cycles that can be performed within one second.  The logical cycle time is 13 microsecs."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTstates",
                                        "label": "Number of T states",
                                        "description": "Number of T states consumed by the algorithm",
                                        "explanation": "To execute the algorithm, we require one T state for each of the 0 T gates, four T states for each of the 1,088,452,062,660 CCZ and 0 CCiX gates, as well as No rotations in algorithm for each of the 0 single-qubit rotation gates with arbitrary angle rotation."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactories",
                                        "label": "Number of T factories",
                                        "description": "Number of T factories capable of producing the demanded 4,353,808,250,640 T states during the algorithm's runtime",
                                        "explanation": "The total number of T factories 5,606 that are executed in parallel is computed as $\\left\\lceil\\dfrac{\\text{T states}\\cdot\\text{T factory duration}}{\\text{T states per T factory}\\cdot\\text{algorithm runtime}}\\right\\rceil = \\left\\lceil\\dfrac{4,353,808,250,640 \\cdot 156,800\\;\\text{ns}}{1 \\cdot 43,102,701,681,336,000\\;\\text{ns}}\\right\\rceil$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTfactoryRuns",
                                        "label": "Number of T factory invocations",
                                        "description": "Number of times all T factories are invoked",
                                        "explanation": "In order to prepare the 4,353,808,250,640 T states, the 5,606 copies of the T factory are repeatedly invoked 776,633,652 times."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForAlgorithm",
                                        "label": "Physical algorithmic qubits",
                                        "description": "Number of physical qubits for the algorithm after layout",
                                        "explanation": "The 215,476,074 are the product of the 98,933 logical qubits after layout and the 2,178 physical qubits that encode a single logical qubit."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsForTfactories",
                                        "label": "Physical T factory qubits",
                                        "description": "Number of physical qubits for the T factories",
                                        "explanation": "Each T factory requires 55,080 physical qubits and we run 5,606 in parallel, therefore we need $308,778,480 = 55,080 \\cdot 5,606$ qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalQubitErrorRate",
                                        "label": "Required logical qubit error rate",
                                        "description": "The minimum logical qubit error rate required to run the algorithm within the error budget",
                                        "explanation": "The minimum logical qubit error rate is obtained by dividing the logical error probability 4.50e-1 by the product of 98,933 logical qubits and the total cycle count 3,265,356,187,980."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/requiredLogicalTstateErrorRate",
                                        "label": "Required logical T state error rate",
                                        "description": "The minimum T state error rate required for distilled T states",
                                        "explanation": "The minimum T state error rate is obtained by dividing the T distillation error probability 4.50e-1 by the total number of T states 4,353,808,250,640."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numTsPerRotation",
                                        "label": "Number of T states per rotation",
                                        "description": "Number of T states to implement a rotation with an arbitrary angle",
                                        "explanation": "The number of T states to implement a rotation with an arbitrary angle is $\\lceil 0.53 \\log_2(0 / 0) + 4.86\\rceil$ [[arXiv:2203.10064](https://arxiv.org/abs/2203.10064)].  For simplicity, we use this formula for all single-qubit arbitrary angle rotations, and do not distinguish between best, worst, and average cases."
                                    }
                                ]
                            },
                            {
                                "title": "Logical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qecScheme/name",
                                        "label": "QEC scheme",
                                        "description": "Name of QEC scheme",
                                        "explanation": "You can load pre-defined QEC schemes by using the name `surface_code` or `floquet_code`. The latter only works with Majorana qubits."
                                    },
                                    {
                                        "path": "logicalQubit/codeDistance",
                                        "label": "Code distance",
                                        "description": "Required code distance for error correction",
                                        "explanation": "The code distance is the smallest odd integer greater or equal to $\\dfrac{2\\log(0.03 / 0.0000000000000000013929668261626498)}{\\log(0.01/0.001)} - 1$"
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits per logical qubit",
                                        "explanation": "The number of physical qubits per logical qubit are evaluated using the formula 2 * codeDistance * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCycleTime",
                                        "label": "Logical cycle time",
                                        "description": "Duration of a logical cycle in nanoseconds",
                                        "explanation": "The runtime of one logical cycle in nanoseconds is evaluated using the formula (4 * twoQubitGateTime + 2 * oneQubitMeasurementTime) * codeDistance that can be user-specified."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalErrorRate",
                                        "label": "Logical qubit error rate",
                                        "description": "Logical qubit error rate",
                                        "explanation": "The logical qubit error rate is computed as $0.03 \\cdot \\left(\\dfrac{0.001}{0.01}\\right)^\\frac{33 + 1}{2}$"
                                    },
                                    {
                                        "path": "jobParams/qecScheme/crossingPrefactor",
                                        "label": "Crossing prefactor",
                                        "description": "Crossing prefactor used in QEC scheme",
                                        "explanation": "The crossing prefactor is usually extracted numerically from simulations when fitting an exponential curve to model the relationship between logical and physical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/errorCorrectionThreshold",
                                        "label": "Error correction threshold",
                                        "description": "Error correction threshold used in QEC scheme",
                                        "explanation": "The error correction threshold is the physical error rate below which the error rate of the logical qubit is less than the error rate of the physical qubit that constitute it.  This value is usually extracted numerically from simulations of the logical error rate."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/logicalCycleTime",
                                        "label": "Logical cycle time formula",
                                        "description": "QEC scheme formula used to compute logical cycle time",
                                        "explanation": "This is the formula that is used to compute the logical cycle time 13,200 ns."
                                    },
                                    {
                                        "path": "jobParams/qecScheme/physicalQubitsPerLogicalQubit",
                                        "label": "Physical qubits formula",
                                        "description": "QEC scheme formula used to compute number of physical qubits per logical qubit",
                                        "explanation": "This is the formula that is used to compute the number of physical qubits per logical qubits 2,178."
                                    }
                                ]
                            },
                            {
                                "title": "T factory parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/tfactoryPhysicalQubits",
                                        "label": "Physical qubits",
                                        "description": "Number of physical qubits for a single T factory",
                                        "explanation": "This corresponds to the maximum number of physical qubits over all rounds of T distillation units in a T factory.  A round of distillation contains of multiple copies of distillation units to achieve the required success probability of producing a T state with the expected logical T state error rate."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntime",
                                        "label": "Runtime",
                                        "description": "Runtime of a single T factory",
                                        "explanation": "The runtime of a single T factory is the accumulated runtime of executing each round in a T factory."
                                    },
                                    {
                                        "path": "tfactory/numTstates",
                                        "label": "Number of output T states per run",
                                        "description": "Number of output T states produced in a single run of T factory",
                                        "explanation": "The T factory takes as input 255 noisy physical T states with an error rate of 0.001 and produces 1 T states with an error rate of 2.17e-14."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numInputTstates",
                                        "label": "Number of input T states per run",
                                        "description": "Number of physical input T states consumed in a single run of a T factory",
                                        "explanation": "This value includes the physical input T states of all copies of the distillation unit in the first round."
                                    },
                                    {
                                        "path": "tfactory/numRounds",
                                        "label": "Distillation rounds",
                                        "description": "The number of distillation rounds",
                                        "explanation": "This is the number of distillation rounds.  In each round one or multiple copies of some distillation unit is executed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/numUnitsPerRound",
                                        "label": "Distillation units per round",
                                        "description": "The number of units in each round of distillation",
                                        "explanation": "This is the number of copies for the distillation units per round."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/unitNamePerRound",
                                        "label": "Distillation units",
                                        "description": "The types of distillation units",
                                        "explanation": "These are the types of distillation units that are executed in each round.  The units can be either physical or logical, depending on what type of qubit they are operating.  Space-efficient units require fewer qubits for the cost of longer runtime compared to Reed-Muller preparation units."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/codeDistancePerRound",
                                        "label": "Distillation code distances",
                                        "description": "The code distance in each round of distillation",
                                        "explanation": "This is the code distance used for the units in each round.  If the code distance is 1, then the distillation unit operates on physical qubits instead of error-corrected logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/physicalQubitsPerRound",
                                        "label": "Number of physical qubits per round",
                                        "description": "The number of physical qubits used in each round of distillation",
                                        "explanation": "The maximum number of physical qubits over all rounds is the number of physical qubits for the T factory, since qubits are reused by different rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tfactoryRuntimePerRound",
                                        "label": "Runtime per round",
                                        "description": "The runtime of each distillation round",
                                        "explanation": "The runtime of the T factory is the sum of the runtimes in all rounds."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/tstateLogicalErrorRate",
                                        "label": "Logical T state error rate",
                                        "description": "Logical T state error rate",
                                        "explanation": "This is the logical T state error rate achieved by the T factory which is equal or smaller than the required error rate 1.03e-13."
                                    }
                                ]
                            },
                            {
                                "title": "Pre-layout logical resources",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsNumQubits",
                                        "label": "Logical qubits (pre-layout)",
                                        "description": "Number of logical qubits in the input quantum program",
                                        "explanation": "We determine 98,933 algorithmic logical qubits from this number by assuming to align them in a 2D grid.  Auxiliary qubits are added to allow for sufficient space to execute multi-qubit Pauli measurements on all or a subset of the logical qubits."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsTCount",
                                        "label": "T gates",
                                        "description": "Number of T gates in the input quantum program",
                                        "explanation": "This includes all T gates and adjoint T gates, but not T gates used to implement rotation gates with arbitrary angle, CCZ gates, or CCiX gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationCount",
                                        "label": "Rotation gates",
                                        "description": "Number of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all rotation gates. If an angle corresponds to a Pauli, Clifford, or T gate, it is not accounted for in this number."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsRotationDepth",
                                        "label": "Rotation depth",
                                        "description": "Depth of rotation gates in the input quantum program",
                                        "explanation": "This is the number of all non-Clifford layers that include at least one single-qubit rotation gate with an arbitrary angle."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCczCount",
                                        "label": "CCZ gates",
                                        "description": "Number of CCZ-gates in the input quantum program",
                                        "explanation": "This is the number of CCZ gates."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsCcixCount",
                                        "label": "CCiX gates",
                                        "description": "Number of CCiX-gates in the input quantum program",
                                        "explanation": "This is the number of CCiX gates, which applies $-iX$ controlled on two control qubits [[1212.5069](https://arxiv.org/abs/1212.5069)]."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/logicalCountsMeasurementCount",
                                        "label": "Measurement operations",
                                        "description": "Number of single qubit measurements in the input quantum program",
                                        "explanation": "This is the number of single qubit measurements in Pauli basis that are used in the input program.  Note that all measurements are counted, however, the measurement result is is determined randomly (with a fixed seed) to be 0 or 1 with a probability of 50%."
                                    }
                                ]
                            },
                            {
                                "title": "Assumed error budget",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/errorBudget",
                                        "label": "Total error budget",
                                        "description": "Total error budget for the algorithm",
                                        "explanation": "The total error budget sets the overall allowed error for the algorithm, i.e., the number of times it is allowed to fail.  Its value must be between 0 and 1 and the default value is 0.001, which corresponds to 0.1%, and means that the algorithm is allowed to fail once in 1000 executions.  This parameter is highly application specific. For example, if one is running Shor's algorithm for factoring integers, a large value for the error budget may be tolerated as one can check that the output are indeed the prime factors of the input.  On the other hand, a much smaller error budget may be needed for an algorithm solving a problem with a solution which cannot be efficiently verified.  This budget $\\epsilon = \\epsilon_{\\log} + \\epsilon_{\\rm dis} + \\epsilon_{\\rm syn}$ is uniformly distributed and applies to errors $\\epsilon_{\\log}$ to implement logical qubits, an error budget $\\epsilon_{\\rm dis}$ to produce T states through distillation, and an error budget $\\epsilon_{\\rm syn}$ to synthesize rotation gates with arbitrary angles.  Note that for distillation and rotation synthesis, the respective error budgets $\\epsilon_{\\rm dis}$ and $\\epsilon_{\\rm syn}$ are uniformly distributed among all T states and all rotation gates, respectively. If there are no rotation gates in the input algorithm, the error budget is uniformly distributed to logical errors and T state errors."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetLogical",
                                        "label": "Logical error probability",
                                        "description": "Probability of at least one logical error",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetTstates",
                                        "label": "T distillation error probability",
                                        "description": "Probability of at least one faulty T distillation",
                                        "explanation": "This is one third of the total error budget 9.00e-1 if the input algorithm contains rotation with gates with arbitrary angles, or one half of it, otherwise."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/errorBudgetRotations",
                                        "label": "Rotation synthesis error probability",
                                        "description": "Probability of at least one failed rotation synthesis",
                                        "explanation": "This is one third of the total error budget 9.00e-1."
                                    }
                                ]
                            },
                            {
                                "title": "Physical qubit parameters",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "jobParams/qubitParams/name",
                                        "label": "Qubit name",
                                        "description": "Some descriptive name for the qubit model",
                                        "explanation": "You can load pre-defined qubit parameters by using the names `qubit_gate_ns_e3`, `qubit_gate_ns_e4`, `qubit_gate_us_e3`, `qubit_gate_us_e4`, `qubit_maj_ns_e4`, or `qubit_maj_ns_e6`.  The names of these pre-defined qubit parameters indicate the instruction set (gate-based or Majorana), the operation speed (ns or \u00b5s regime), as well as the fidelity (e.g., e3 for $10^{-3}$ gate error rates)."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/instructionSet",
                                        "label": "Instruction set",
                                        "description": "Underlying qubit technology (gate-based or Majorana)",
                                        "explanation": "When modeling the physical qubit abstractions, we distinguish between two different physical instruction sets that are used to operate the qubits.  The physical instruction set can be either *gate-based* or *Majorana*.  A gate-based instruction set provides single-qubit measurement, single-qubit gates (incl. T gates), and two-qubit gates.  A Majorana instruction set provides a physical T gate, single-qubit measurement and two-qubit joint measurement operations."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementTime",
                                        "label": "Single-qubit measurement time",
                                        "description": "Operation time for single-qubit measurement (t_meas) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit measurement in the Pauli basis."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateTime",
                                        "label": "Single-qubit gate time",
                                        "description": "Operation time for single-qubit gate (t_gate) in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a single-qubit Clifford operation, e.g., Hadamard or Phase gates."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateTime",
                                        "label": "Two-qubit gate time",
                                        "description": "Operation time for two-qubit gate in ns",
                                        "explanation": "This is the operation time in nanoseconds to perform a two-qubit Clifford operation, e.g., a CNOT or CZ gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateTime",
                                        "label": "T gate time",
                                        "description": "Operation time for a T gate",
                                        "explanation": "This is the operation time in nanoseconds to execute a T gate."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitMeasurementErrorRate",
                                        "label": "Single-qubit measurement error rate",
                                        "description": "Error rate for single-qubit measurement",
                                        "explanation": "This is the probability in which a single-qubit measurement in the Pauli basis may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/oneQubitGateErrorRate",
                                        "label": "Single-qubit error rate",
                                        "description": "Error rate for single-qubit Clifford gate (p)",
                                        "explanation": "This is the probability in which a single-qubit Clifford operation, e.g., Hadamard or Phase gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/twoQubitGateErrorRate",
                                        "label": "Two-qubit error rate",
                                        "description": "Error rate for two-qubit Clifford gate",
                                        "explanation": "This is the probability in which a two-qubit Clifford operation, e.g., CNOT or CZ gates, may fail."
                                    },
                                    {
                                        "path": "jobParams/qubitParams/tGateErrorRate",
                                        "label": "T gate error rate",
                                        "description": "Error rate to prepare single-qubit T state or apply a T gate (p_T)",
                                        "explanation": "This is the probability in which executing a single T gate may fail."
                                    }
                                ]
                            },
                            {
                                "title": "Constraints",
                                "alwaysVisible": false,
                                "entries": [
                                    {
                                        "path": "physicalCountsFormatted/logicalDepthFactor",
                                        "label": "Logical depth factor",
                                        "description": "Factor the initial number of logical cycles is multiplied by",
                                        "explanation": "This is the factor takes into account a potential overhead to the initial number of logical cycles."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxTFactories",
                                        "label": "Maximum number of T factories",
                                        "description": "The maximum number of T factories can be utilized during the algorithm's runtime",
                                        "explanation": "This is the maximum number of T factories used for producing the demanded T states, which can be created and executed by the algorithm in parallel."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxDuration",
                                        "label": "Maximum runtime duration",
                                        "description": "The maximum runtime duration allowed for the algorithm runtime",
                                        "explanation": "This is the maximum time allowed to the algorithm. If specified, the estimator targets to minimize the number of physical qubits consumed by the algorithm for runtimes under the maximum allowed."
                                    },
                                    {
                                        "path": "physicalCountsFormatted/maxPhysicalQubits",
                                        "label": "Maximum number of physical qubits",
                                        "description": "The maximum number of physical qubits allowed for utilization to the algorith",
                                        "explanation": "This is the maximum number of physical qubits available to the algorithm. If specified, the estimator targets to minimize the runtime of the algorithm with number of physical qubits consumed not exceeding this maximum."
                                    }
                                ]
                            }
                        ],
                        "assumptions": [
                            "_More details on the following lists of assumptions can be found in the paper [Accessing requirements for scaling quantum computers and their applications](https://aka.ms/AQ/RE/Paper)._",
                            "**Uniform independent physical noise.** We assume that the noise on physical qubits and physical qubit operations is the standard circuit noise model. In particular we assume error events at different space-time locations are independent and that error rates are uniform across the system in time and space.",
                            "**Efficient classical computation.** We assume that classical overhead (compilation, control, feedback, readout, decoding, etc.) does not dominate the overall cost of implementing the full quantum algorithm.",
                            "**Extraction circuits for planar quantum ISA.** We assume that stabilizer extraction circuits with similar depth and error correction performance to those for standard surface and Hastings-Haah code patches can be constructed to implement all operations of the planar quantum ISA (instruction set architecture).",
                            "**Uniform independent logical noise.** We assume that the error rate of a logical operation is approximately equal to its space-time volume (the number of tiles multiplied by the number of logical time steps) multiplied by the error rate of a logical qubit in a standard one-tile patch in one logical time step.",
                            "**Negligible Clifford costs for synthesis.** We assume that the space overhead for synthesis and space and time overhead for transport of magic states within magic state factories and to synthesis qubits are all negligible.",
                            "**Smooth magic state consumption rate.** We assume that the rate of T state consumption throughout the compiled algorithm is almost constant, or can be made almost constant without significantly increasing the number of logical time steps for the algorithm."
                        ]
                    }
                }
            }
        ]
    }
]